// This code was AUTOGENERATED using the library.
// Please DO NOT EDIT THIS FILE.

package token_group

import (
	"errors"

	binary "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go/programs/common"
	format "github.com/gagliardetto/solana-go/text/format"
	treeout "github.com/gagliardetto/treeout"
)

// Initialize Instruction
type Initialize struct {
	// Update authority for the group
	UpdateAuthority *common.PublicKey
	// The maximum number of group members
	MaxSize *uint32
	// [0] = [WRITE] group “
	// [1] = [] mint “
	// [2] = [SIGNER] mintAuthority “
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeInstructionBuilder creates a new `Initialize` instruction builder.
func NewInitializeInstructionBuilder() *Initialize {
	return &Initialize{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewInitializeInstruction
//
// Parameters:
//
//	updateAuthority: Update authority for the group
//	maxSize: The maximum number of group members
//	group:
//	mint:
//	mintAuthority:
func NewInitializeInstruction(
	updateAuthority common.PublicKey,
	maxSize uint32,
	group common.PublicKey,
	mint common.PublicKey,
	mintAuthority common.PublicKey,
) *Initialize {
	return NewInitializeInstructionBuilder().
		SetUpdateAuthority(updateAuthority).
		SetMaxSize(maxSize).
		SetGroupAccount(group).
		SetMintAccount(mint).
		SetMintAuthorityAccount(mintAuthority)
}

// SetUpdateAuthority sets the "updateAuthority" parameter.
func (obj *Initialize) SetUpdateAuthority(updateAuthority common.PublicKey) *Initialize {
	obj.UpdateAuthority = &updateAuthority
	return obj
}

// SetMaxSize sets the "maxSize" parameter.
func (obj *Initialize) SetMaxSize(maxSize uint32) *Initialize {
	obj.MaxSize = &maxSize
	return obj
}

// SetGroupAccount sets the "group" parameter.
func (obj *Initialize) SetGroupAccount(group common.PublicKey) *Initialize {
	obj.AccountMetaSlice[0] = common.Meta(group).WRITE()
	return obj
}

// GetGroupAccount gets the "group" parameter.
func (obj *Initialize) GetGroupAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
func (obj *Initialize) SetMintAccount(mint common.PublicKey) *Initialize {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
func (obj *Initialize) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
func (obj *Initialize) SetMintAuthorityAccount(mintAuthority common.PublicKey, multiSigners ...common.PublicKey) *Initialize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(mintAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(mintAuthority).SIGNER()
	}
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
func (obj *Initialize) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *Initialize) SetProgramId(programId *common.PublicKey) *Initialize {
	obj._programId = programId
	return obj
}

func (obj *Initialize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes(Instruction_Initialize[:]),
		},
		programId: obj._programId,
		typeIdLen: 8,
	}
}

func (obj *Initialize) Validate() error {
	if obj.UpdateAuthority == nil {
		return errors.New("[Initialize] updateAuthority param is not set")
	}
	if obj.MaxSize == nil {
		return errors.New("[Initialize] maxSize param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Initialize] accounts.group is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Initialize] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Initialize] accounts.mintAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Initialize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Initialize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UpdateAuthority); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.MaxSize); err != nil {
		return err
	}
	return nil
}

func (obj *Initialize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UpdateAuthority); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.MaxSize); err != nil {
		return err
	}
	return nil
}

func (obj *Initialize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Initialize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UpdateAuthority", *obj.UpdateAuthority))
						paramsBranch.Child(format.Param("        MaxSize", *obj.MaxSize))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("        group", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("         mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("mintAuthority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// UpdateGroupMaxSize Instruction
type UpdateGroupMaxSize struct {
	// New max size for the group
	MaxSize *uint32
	// [0] = [WRITE] group `Group`
	// [1] = [SIGNER] updateAuthority `Update authority`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdateGroupMaxSizeInstructionBuilder creates a new `UpdateGroupMaxSize` instruction builder.
func NewUpdateGroupMaxSizeInstructionBuilder() *UpdateGroupMaxSize {
	return &UpdateGroupMaxSize{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewUpdateGroupMaxSizeInstruction
//
// Parameters:
//
//	maxSize: New max size for the group
//	group: Group
//	updateAuthority: Update authority
func NewUpdateGroupMaxSizeInstruction(
	maxSize uint32,
	group common.PublicKey,
	updateAuthority common.PublicKey,
) *UpdateGroupMaxSize {
	return NewUpdateGroupMaxSizeInstructionBuilder().
		SetMaxSize(maxSize).
		SetGroupAccount(group).
		SetUpdateAuthorityAccount(updateAuthority)
}

// SetMaxSize sets the "maxSize" parameter.
func (obj *UpdateGroupMaxSize) SetMaxSize(maxSize uint32) *UpdateGroupMaxSize {
	obj.MaxSize = &maxSize
	return obj
}

// SetGroupAccount sets the "group" parameter.
// Group
func (obj *UpdateGroupMaxSize) SetGroupAccount(group common.PublicKey) *UpdateGroupMaxSize {
	obj.AccountMetaSlice[0] = common.Meta(group).WRITE()
	return obj
}

// GetGroupAccount gets the "group" parameter.
// Group
func (obj *UpdateGroupMaxSize) GetGroupAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority
func (obj *UpdateGroupMaxSize) SetUpdateAuthorityAccount(updateAuthority common.PublicKey, multiSigners ...common.PublicKey) *UpdateGroupMaxSize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority).SIGNER()
	}
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority
func (obj *UpdateGroupMaxSize) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *UpdateGroupMaxSize) SetProgramId(programId *common.PublicKey) *UpdateGroupMaxSize {
	obj._programId = programId
	return obj
}

func (obj *UpdateGroupMaxSize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes(Instruction_UpdateGroupMaxSize[:]),
		},
		programId: obj._programId,
		typeIdLen: 8,
	}
}

func (obj *UpdateGroupMaxSize) Validate() error {
	if obj.MaxSize == nil {
		return errors.New("[UpdateGroupMaxSize] maxSize param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UpdateGroupMaxSize] accounts.group is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UpdateGroupMaxSize] accounts.updateAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UpdateGroupMaxSize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UpdateGroupMaxSize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.MaxSize); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateGroupMaxSize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.MaxSize); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateGroupMaxSize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UpdateGroupMaxSize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("MaxSize", *obj.MaxSize))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          group", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// UpdateGroupAuthority Instruction
type UpdateGroupAuthority struct {
	// New authority for the group, or unset if `None`
	NewAuthority *common.PublicKey
	// [0] = [WRITE] group `Group`
	// [1] = [SIGNER] updateAuthority `Current update authority`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdateGroupAuthorityInstructionBuilder creates a new `UpdateGroupAuthority` instruction builder.
func NewUpdateGroupAuthorityInstructionBuilder() *UpdateGroupAuthority {
	return &UpdateGroupAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewUpdateGroupAuthorityInstruction
//
// Parameters:
//
//	newAuthority: New authority for the group, or unset if `None`
//	group: Group
//	updateAuthority: Current update authority
func NewUpdateGroupAuthorityInstruction(
	newAuthority common.PublicKey,
	group common.PublicKey,
	updateAuthority common.PublicKey,
) *UpdateGroupAuthority {
	return NewUpdateGroupAuthorityInstructionBuilder().
		SetNewAuthority(newAuthority).
		SetGroupAccount(group).
		SetUpdateAuthorityAccount(updateAuthority)
}

// SetNewAuthority sets the "newAuthority" parameter.
func (obj *UpdateGroupAuthority) SetNewAuthority(newAuthority common.PublicKey) *UpdateGroupAuthority {
	obj.NewAuthority = &newAuthority
	return obj
}

// SetGroupAccount sets the "group" parameter.
// Group
func (obj *UpdateGroupAuthority) SetGroupAccount(group common.PublicKey) *UpdateGroupAuthority {
	obj.AccountMetaSlice[0] = common.Meta(group).WRITE()
	return obj
}

// GetGroupAccount gets the "group" parameter.
// Group
func (obj *UpdateGroupAuthority) GetGroupAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Current update authority
func (obj *UpdateGroupAuthority) SetUpdateAuthorityAccount(updateAuthority common.PublicKey, multiSigners ...common.PublicKey) *UpdateGroupAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority).SIGNER()
	}
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Current update authority
func (obj *UpdateGroupAuthority) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *UpdateGroupAuthority) SetProgramId(programId *common.PublicKey) *UpdateGroupAuthority {
	obj._programId = programId
	return obj
}

func (obj *UpdateGroupAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes(Instruction_UpdateGroupAuthority[:]),
		},
		programId: obj._programId,
		typeIdLen: 8,
	}
}

func (obj *UpdateGroupAuthority) Validate() error {
	if obj.NewAuthority == nil {
		return errors.New("[UpdateGroupAuthority] newAuthority param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UpdateGroupAuthority] accounts.group is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UpdateGroupAuthority] accounts.updateAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UpdateGroupAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UpdateGroupAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.NewAuthority); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateGroupAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.NewAuthority); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateGroupAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UpdateGroupAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("NewAuthority", *obj.NewAuthority))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          group", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// InitializeMember Instruction
type InitializeMember struct {
	// [0] = [WRITE] member `Group`
	// [1] = [] memberMint `Member mint`
	// [2] = [SIGNER] memberMintAuthority `Member mint authority`
	// [3] = [WRITE] group `Group`
	// [4] = [SIGNER] groupUpdateAuthority `Group update authority`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMemberInstructionBuilder creates a new `InitializeMember` instruction builder.
func NewInitializeMemberInstructionBuilder() *InitializeMember {
	return &InitializeMember{
		AccountMetaSlice: make(common.AccountMetaSlice, 5),
	}
}

// NewInitializeMemberInstruction
//
// Parameters:
//
//	member: Group
//	memberMint: Member mint
//	memberMintAuthority: Member mint authority
//	group: Group
//	groupUpdateAuthority: Group update authority
func NewInitializeMemberInstruction(
	member common.PublicKey,
	memberMint common.PublicKey,
	memberMintAuthority common.PublicKey,
	group common.PublicKey,
	groupUpdateAuthority common.PublicKey,
) *InitializeMember {
	return NewInitializeMemberInstructionBuilder().
		SetMemberAccount(member).
		SetMemberMintAccount(memberMint).
		SetMemberMintAuthorityAccount(memberMintAuthority).
		SetGroupAccount(group).
		SetGroupUpdateAuthorityAccount(groupUpdateAuthority)
}

// SetMemberAccount sets the "member" parameter.
// Group
func (obj *InitializeMember) SetMemberAccount(member common.PublicKey) *InitializeMember {
	obj.AccountMetaSlice[0] = common.Meta(member).WRITE()
	return obj
}

// GetMemberAccount gets the "member" parameter.
// Group
func (obj *InitializeMember) GetMemberAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMemberMintAccount sets the "memberMint" parameter.
// Member mint
func (obj *InitializeMember) SetMemberMintAccount(memberMint common.PublicKey) *InitializeMember {
	obj.AccountMetaSlice[1] = common.Meta(memberMint)
	return obj
}

// GetMemberMintAccount gets the "memberMint" parameter.
// Member mint
func (obj *InitializeMember) GetMemberMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMemberMintAuthorityAccount sets the "memberMintAuthority" parameter.
// Member mint authority
func (obj *InitializeMember) SetMemberMintAuthorityAccount(memberMintAuthority common.PublicKey) *InitializeMember {
	obj.AccountMetaSlice[2] = common.Meta(memberMintAuthority).SIGNER()
	return obj
}

// GetMemberMintAuthorityAccount gets the "memberMintAuthority" parameter.
// Member mint authority
func (obj *InitializeMember) GetMemberMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetGroupAccount sets the "group" parameter.
// Group
func (obj *InitializeMember) SetGroupAccount(group common.PublicKey) *InitializeMember {
	obj.AccountMetaSlice[3] = common.Meta(group).WRITE()
	return obj
}

// GetGroupAccount gets the "group" parameter.
// Group
func (obj *InitializeMember) GetGroupAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetGroupUpdateAuthorityAccount sets the "groupUpdateAuthority" parameter.
// Group update authority
func (obj *InitializeMember) SetGroupUpdateAuthorityAccount(groupUpdateAuthority common.PublicKey, multiSigners ...common.PublicKey) *InitializeMember {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[4] = common.Meta(groupUpdateAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[4] = common.Meta(groupUpdateAuthority).SIGNER()
	}
	return obj
}

// GetGroupUpdateAuthorityAccount gets the "groupUpdateAuthority" parameter.
// Group update authority
func (obj *InitializeMember) GetGroupUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

func (obj *InitializeMember) SetProgramId(programId *common.PublicKey) *InitializeMember {
	obj._programId = programId
	return obj
}

func (obj *InitializeMember) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes(Instruction_InitializeMember[:]),
		},
		programId: obj._programId,
		typeIdLen: 8,
	}
}

func (obj *InitializeMember) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMember] accounts.member is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeMember] accounts.memberMint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[InitializeMember] accounts.memberMintAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[InitializeMember] accounts.group is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[InitializeMember] accounts.groupUpdateAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMember) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMember) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *InitializeMember) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *InitializeMember) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMember")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=5]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("              member", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("          memberMint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta(" memberMintAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("               group", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("groupUpdateAuthority", obj.AccountMetaSlice.Get(4)))
					})
				})
		})
}
