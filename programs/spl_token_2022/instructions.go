// This code was AUTOGENERATED using the library.
// Please DO NOT EDIT THIS FILE.

package spl_token_2022

import (
	"errors"

	binary "github.com/gagliardetto/binary"
	"github.com/gagliardetto/solana-go/programs/common"
	format "github.com/gagliardetto/solana-go/text/format"
	treeout "github.com/gagliardetto/treeout"
)

// InitializeMint Instruction
type InitializeMint struct {
	Decimals        *uint8
	Authority       *common.PublicKey
	FreezeAuthority *common.PublicKey `bin:"optional"`
	// [0] = [WRITE] mint `The mint to initialize.`
	// [1] = [] rent `Rent sysvar`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMintInstructionBuilder creates a new `InitializeMint` instruction builder.
func NewInitializeMintInstructionBuilder() *InitializeMint {
	return &InitializeMint{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewInitializeMintInstruction
//
// Parameters:
//
//	decimals:
//	authority:
//	freezeAuthority:
//	mint: The mint to initialize.
//	rent: Rent sysvar
func NewInitializeMintInstruction(
	decimals uint8,
	authority common.PublicKey,
	// optional,
	freezeAuthority *common.PublicKey,
	mint common.PublicKey,
	rent common.PublicKey,
) *InitializeMint {
	return NewInitializeMintInstructionBuilder().
		SetDecimals(decimals).
		SetAuthority(authority).
		SetFreezeAuthority(freezeAuthority).
		SetMintAccount(mint).
		SetRentAccount(rent)
}

// SetDecimals sets the "decimals" parameter.
func (obj *InitializeMint) SetDecimals(decimals uint8) *InitializeMint {
	obj.Decimals = &decimals
	return obj
}

// SetAuthority sets the "authority" parameter.
func (obj *InitializeMint) SetAuthority(authority common.PublicKey) *InitializeMint {
	obj.Authority = &authority
	return obj
}

// SetFreezeAuthority sets the "freezeAuthority" parameter.
func (obj *InitializeMint) SetFreezeAuthority(freezeAuthority *common.PublicKey) *InitializeMint {
	obj.FreezeAuthority = freezeAuthority
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMint) SetMintAccount(mint common.PublicKey) *InitializeMint {
	obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMint) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetRentAccount sets the "rent" parameter.
// Rent sysvar
func (obj *InitializeMint) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *InitializeMint {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent sysvar
func (obj *InitializeMint) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *InitializeMint) SetProgramId(programId *common.PublicKey) *InitializeMint {
	obj._programId = programId
	return obj
}

func (obj *InitializeMint) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeMint}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeMint) Validate() error {
	if obj.Decimals == nil {
		return errors.New("[InitializeMint] decimals param is not set")
	}
	if obj.Authority == nil {
		return errors.New("[InitializeMint] authority param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMint] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeMint] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMint) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMint) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Authority); err != nil {
		return err
	}
	if err = encoder.WriteBool(obj.FreezeAuthority != nil); err != nil {
		return err
	}
	if obj.FreezeAuthority != nil {
		if err = encoder.Encode(obj.FreezeAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMint) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Authority); err != nil {
		return err
	}
	if ok, err := decoder.ReadBool(); err != nil {
		return err
	} else if ok {
		if err = decoder.Decode(&obj.FreezeAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMint) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMint")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=3]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("       Decimals", *obj.Decimals))
						paramsBranch.Child(format.Param("      Authority", *obj.Authority))
						paramsBranch.Child(format.Param("FreezeAuthority (OPT)", obj.FreezeAuthority))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("rent", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// InitializeAccount Instruction
type InitializeAccount struct {
	// [0] = [WRITE] account `The account to initialize.`
	// [1] = [] mint `The mint this account will be associated with.`
	// [2] = [] authority `The new account's owner/multisignature.`
	// [3] = [] rent `Rent sysvar`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeAccountInstructionBuilder creates a new `InitializeAccount` instruction builder.
func NewInitializeAccountInstructionBuilder() *InitializeAccount {
	return &InitializeAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewInitializeAccountInstruction
//
// Parameters:
//
//	account: The account to initialize.
//	mint: The mint this account will be associated with.
//	authority: The new account's owner/multisignature.
//	rent: Rent sysvar
func NewInitializeAccountInstruction(
	account common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
	rent common.PublicKey,
) *InitializeAccount {
	return NewInitializeAccountInstructionBuilder().
		SetAccountAccount(account).
		SetMintAccount(mint).
		SetAuthorityAccount(authority).
		SetRentAccount(rent)
}

// SetAccountAccount sets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount) SetAccountAccount(account common.PublicKey) *InitializeAccount {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount) SetMintAccount(mint common.PublicKey) *InitializeAccount {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The new account's owner/multisignature.
func (obj *InitializeAccount) SetAuthorityAccount(authority common.PublicKey) *InitializeAccount {
	obj.AccountMetaSlice[2] = common.Meta(authority)
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The new account's owner/multisignature.
func (obj *InitializeAccount) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetRentAccount sets the "rent" parameter.
// Rent sysvar
func (obj *InitializeAccount) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *InitializeAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent sysvar
func (obj *InitializeAccount) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *InitializeAccount) SetProgramId(programId *common.PublicKey) *InitializeAccount {
	obj._programId = programId
	return obj
}

func (obj *InitializeAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeAccount] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[InitializeAccount] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[InitializeAccount] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *InitializeAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *InitializeAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("  account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("     rent", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// InitializeMultisig Instruction
type InitializeMultisig struct {
	M *uint8
	// [0] = [WRITE] account `The multisignature account to initialize.`
	// [1] = [] rent `Rent sysvar`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMultisigInstructionBuilder creates a new `InitializeMultisig` instruction builder.
func NewInitializeMultisigInstructionBuilder() *InitializeMultisig {
	return &InitializeMultisig{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewInitializeMultisigInstruction
//
// Parameters:
//
//	m:
//	account: The multisignature account to initialize.
//	rent: Rent sysvar
func NewInitializeMultisigInstruction(
	m uint8,
	account common.PublicKey,
	rent common.PublicKey,
) *InitializeMultisig {
	return NewInitializeMultisigInstructionBuilder().
		SetM(m).
		SetAccountAccount(account).
		SetRentAccount(rent)
}

// SetM sets the "m" parameter.
func (obj *InitializeMultisig) SetM(m uint8) *InitializeMultisig {
	obj.M = &m
	return obj
}

// SetAccountAccount sets the "account" parameter.
// The multisignature account to initialize.
func (obj *InitializeMultisig) SetAccountAccount(account common.PublicKey) *InitializeMultisig {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The multisignature account to initialize.
func (obj *InitializeMultisig) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetRentAccount sets the "rent" parameter.
// Rent sysvar
func (obj *InitializeMultisig) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *InitializeMultisig {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent sysvar
func (obj *InitializeMultisig) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *InitializeMultisig) SetProgramId(programId *common.PublicKey) *InitializeMultisig {
	obj._programId = programId
	return obj
}

func (obj *InitializeMultisig) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeMultisig}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeMultisig) Validate() error {
	if obj.M == nil {
		return errors.New("[InitializeMultisig] m param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMultisig] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeMultisig] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMultisig) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMultisig) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.M); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeMultisig) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.M); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeMultisig) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMultisig")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("M", *obj.M))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   rent", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// Transfer Instruction
type Transfer struct {
	Amount *uint64
	// [0] = [WRITE] source `The source account.`
	// [1] = [WRITE] destination `The destination account.`
	// [2] = [SIGNER] authority `The source account's owner/delegate.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferInstructionBuilder creates a new `Transfer` instruction builder.
func NewTransferInstructionBuilder() *Transfer {
	return &Transfer{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewTransferInstruction
//
// Parameters:
//
//	amount:
//	source: The source account.
//	destination: The destination account.
//	authority: The source account's owner/delegate.
func NewTransferInstruction(
	amount uint64,
	source common.PublicKey,
	destination common.PublicKey,
	authority common.PublicKey,
) *Transfer {
	return NewTransferInstructionBuilder().
		SetAmount(amount).
		SetSourceAccount(source).
		SetDestinationAccount(destination).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *Transfer) SetAmount(amount uint64) *Transfer {
	obj.Amount = &amount
	return obj
}

// SetSourceAccount sets the "source" parameter.
// The source account.
func (obj *Transfer) SetSourceAccount(source common.PublicKey) *Transfer {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// The source account.
func (obj *Transfer) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDestinationAccount sets the "destination" parameter.
// The destination account.
func (obj *Transfer) SetDestinationAccount(destination common.PublicKey) *Transfer {
	obj.AccountMetaSlice[1] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// The destination account.
func (obj *Transfer) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The source account's owner/delegate.
func (obj *Transfer) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *Transfer {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The source account's owner/delegate.
func (obj *Transfer) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *Transfer) SetProgramId(programId *common.PublicKey) *Transfer {
	obj._programId = programId
	return obj
}

func (obj *Transfer) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Transfer}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Transfer) Validate() error {
	if obj.Amount == nil {
		return errors.New("[Transfer] amount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Transfer] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Transfer] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Transfer] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Transfer) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Transfer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Transfer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Transfer) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Transfer")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Amount", *obj.Amount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("destination", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// Approve Instruction
type Approve struct {
	Amount *uint64
	// [0] = [WRITE] source `The source account.`
	// [1] = [] delegate `The delegate.`
	// [2] = [SIGNER] authority `The source account owner.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewApproveInstructionBuilder creates a new `Approve` instruction builder.
func NewApproveInstructionBuilder() *Approve {
	return &Approve{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewApproveInstruction
//
// Parameters:
//
//	amount:
//	source: The source account.
//	delegate: The delegate.
//	authority: The source account owner.
func NewApproveInstruction(
	amount uint64,
	source common.PublicKey,
	delegate common.PublicKey,
	authority common.PublicKey,
) *Approve {
	return NewApproveInstructionBuilder().
		SetAmount(amount).
		SetSourceAccount(source).
		SetDelegateAccount(delegate).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *Approve) SetAmount(amount uint64) *Approve {
	obj.Amount = &amount
	return obj
}

// SetSourceAccount sets the "source" parameter.
// The source account.
func (obj *Approve) SetSourceAccount(source common.PublicKey) *Approve {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// The source account.
func (obj *Approve) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateAccount sets the "delegate" parameter.
// The delegate.
func (obj *Approve) SetDelegateAccount(delegate common.PublicKey) *Approve {
	obj.AccountMetaSlice[1] = common.Meta(delegate)
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// The delegate.
func (obj *Approve) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The source account owner.
func (obj *Approve) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *Approve {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The source account owner.
func (obj *Approve) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *Approve) SetProgramId(programId *common.PublicKey) *Approve {
	obj._programId = programId
	return obj
}

func (obj *Approve) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Approve}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Approve) Validate() error {
	if obj.Amount == nil {
		return errors.New("[Approve] amount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Approve] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Approve] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Approve] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Approve) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Approve) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Approve) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Approve) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Approve")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Amount", *obj.Amount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("   source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta(" delegate", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// Revoke Instruction
type Revoke struct {
	// [0] = [WRITE] source `The source account.`
	// [1] = [SIGNER] authority `The source account owner or current delegate.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRevokeInstructionBuilder creates a new `Revoke` instruction builder.
func NewRevokeInstructionBuilder() *Revoke {
	return &Revoke{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewRevokeInstruction
//
// Parameters:
//
//	source: The source account.
//	authority: The source account owner or current delegate.
func NewRevokeInstruction(
	source common.PublicKey,
	authority common.PublicKey,
) *Revoke {
	return NewRevokeInstructionBuilder().
		SetSourceAccount(source).
		SetAuthorityAccount(authority)
}

// SetSourceAccount sets the "source" parameter.
// The source account.
func (obj *Revoke) SetSourceAccount(source common.PublicKey) *Revoke {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// The source account.
func (obj *Revoke) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetAuthorityAccount sets the "authority" parameter.
// The source account owner or current delegate.
func (obj *Revoke) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *Revoke {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The source account owner or current delegate.
func (obj *Revoke) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *Revoke) SetProgramId(programId *common.PublicKey) *Revoke {
	obj._programId = programId
	return obj
}

func (obj *Revoke) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Revoke}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Revoke) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Revoke] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Revoke] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Revoke) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Revoke) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *Revoke) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *Revoke) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Revoke")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("   source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// SetAuthority Instruction
type SetAuthority struct {
	AuthorityType *AuthorityType
	NewAuthority  *common.PublicKey `bin:"optional"`
	// [0] = [WRITE] currentAuthority `The mint or account to change the authority of.`
	// [1] = [SIGNER] accountOrMint `The current authority of the mint or account.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSetAuthorityInstructionBuilder creates a new `SetAuthority` instruction builder.
func NewSetAuthorityInstructionBuilder() *SetAuthority {
	return &SetAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewSetAuthorityInstruction
//
// Parameters:
//
//	authorityType:
//	newAuthority:
//	currentAuthority: The mint or account to change the authority of.
//	accountOrMint: The current authority of the mint or account.
func NewSetAuthorityInstruction(
	authorityType AuthorityType,
	// optional,
	newAuthority *common.PublicKey,
	currentAuthority common.PublicKey,
	accountOrMint common.PublicKey,
) *SetAuthority {
	return NewSetAuthorityInstructionBuilder().
		SetAuthorityType(authorityType).
		SetNewAuthority(newAuthority).
		SetCurrentAuthorityAccount(currentAuthority).
		SetAccountOrMintAccount(accountOrMint)
}

// SetAuthorityType sets the "authorityType" parameter.
func (obj *SetAuthority) SetAuthorityType(authorityType AuthorityType) *SetAuthority {
	obj.AuthorityType = &authorityType
	return obj
}

// SetNewAuthority sets the "newAuthority" parameter.
func (obj *SetAuthority) SetNewAuthority(newAuthority *common.PublicKey) *SetAuthority {
	obj.NewAuthority = newAuthority
	return obj
}

// SetCurrentAuthorityAccount sets the "currentAuthority" parameter.
// The mint or account to change the authority of.
func (obj *SetAuthority) SetCurrentAuthorityAccount(currentAuthority common.PublicKey) *SetAuthority {
	obj.AccountMetaSlice[0] = common.Meta(currentAuthority).WRITE()
	return obj
}

// GetCurrentAuthorityAccount gets the "currentAuthority" parameter.
// The mint or account to change the authority of.
func (obj *SetAuthority) GetCurrentAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetAccountOrMintAccount sets the "accountOrMint" parameter.
// The current authority of the mint or account.
func (obj *SetAuthority) SetAccountOrMintAccount(accountOrMint common.PublicKey, multiSigners ...common.PublicKey) *SetAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(accountOrMint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(accountOrMint).SIGNER()
	}
	return obj
}

// GetAccountOrMintAccount gets the "accountOrMint" parameter.
// The current authority of the mint or account.
func (obj *SetAuthority) GetAccountOrMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *SetAuthority) SetProgramId(programId *common.PublicKey) *SetAuthority {
	obj._programId = programId
	return obj
}

func (obj *SetAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SetAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SetAuthority) Validate() error {
	if obj.AuthorityType == nil {
		return errors.New("[SetAuthority] authorityType param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SetAuthority] accounts.currentAuthority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SetAuthority] accounts.accountOrMint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SetAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SetAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.AuthorityType); err != nil {
		return err
	}
	if err = encoder.WriteUint32(btou32(obj.NewAuthority != nil), binary.LE); err != nil {
		return err
	}
	if obj.NewAuthority != nil {
		if err = encoder.Encode(obj.NewAuthority); err != nil {
			return err
		}
	} else {
		var tmp common.PublicKey
		if err = encoder.Encode(tmp); err != nil {
			return err
		}
	}
	return nil
}

func (obj *SetAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.AuthorityType); err != nil {
		return err
	}
	if v, err := decoder.ReadBytes(4); err != nil {
		return err
	} else {
		if err = decoder.Decode(&obj.NewAuthority); err != nil {
			return err
		}
		if v[0] == 0 {
			obj.NewAuthority = nil
		}
	}
	return nil
}

func (obj *SetAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SetAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("AuthorityType", *obj.AuthorityType))
						paramsBranch.Child(format.Param(" NewAuthority (OPT)", obj.NewAuthority))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("currentAuthority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   accountOrMint", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// MintTo Instruction
type MintTo struct {
	Amount *uint64
	// [0] = [WRITE] mint `The mint.`
	// [1] = [WRITE] to `The account to mint tokens to.`
	// [2] = [SIGNER] authority `The mint's minting authority.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMintToInstructionBuilder creates a new `MintTo` instruction builder.
func NewMintToInstructionBuilder() *MintTo {
	return &MintTo{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewMintToInstruction
//
// Parameters:
//
//	amount:
//	mint: The mint.
//	to: The account to mint tokens to.
//	authority: The mint's minting authority.
func NewMintToInstruction(
	amount uint64,
	mint common.PublicKey,
	to common.PublicKey,
	authority common.PublicKey,
) *MintTo {
	return NewMintToInstructionBuilder().
		SetAmount(amount).
		SetMintAccount(mint).
		SetToAccount(to).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *MintTo) SetAmount(amount uint64) *MintTo {
	obj.Amount = &amount
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint.
func (obj *MintTo) SetMintAccount(mint common.PublicKey) *MintTo {
	obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint.
func (obj *MintTo) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetToAccount sets the "to" parameter.
// The account to mint tokens to.
func (obj *MintTo) SetToAccount(to common.PublicKey) *MintTo {
	obj.AccountMetaSlice[1] = common.Meta(to).WRITE()
	return obj
}

// GetToAccount gets the "to" parameter.
// The account to mint tokens to.
func (obj *MintTo) GetToAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The mint's minting authority.
func (obj *MintTo) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *MintTo {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The mint's minting authority.
func (obj *MintTo) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *MintTo) SetProgramId(programId *common.PublicKey) *MintTo {
	obj._programId = programId
	return obj
}

func (obj *MintTo) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MintTo}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MintTo) Validate() error {
	if obj.Amount == nil {
		return errors.New("[MintTo] amount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[MintTo] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[MintTo] accounts.to is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[MintTo] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MintTo) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MintTo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *MintTo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *MintTo) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MintTo")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Amount", *obj.Amount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("       to", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// Burn Instruction
type Burn struct {
	Amount *uint64
	// [0] = [WRITE] burnFrom `The account to burn from.`
	// [1] = [WRITE] mint `The token mint.`
	// [2] = [SIGNER] authority `The account's owner/delegate.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBurnInstructionBuilder creates a new `Burn` instruction builder.
func NewBurnInstructionBuilder() *Burn {
	return &Burn{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewBurnInstruction
//
// Parameters:
//
//	amount:
//	burnFrom: The account to burn from.
//	mint: The token mint.
//	authority: The account's owner/delegate.
func NewBurnInstruction(
	amount uint64,
	burnFrom common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
) *Burn {
	return NewBurnInstructionBuilder().
		SetAmount(amount).
		SetBurnFromAccount(burnFrom).
		SetMintAccount(mint).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *Burn) SetAmount(amount uint64) *Burn {
	obj.Amount = &amount
	return obj
}

// SetBurnFromAccount sets the "burnFrom" parameter.
// The account to burn from.
func (obj *Burn) SetBurnFromAccount(burnFrom common.PublicKey) *Burn {
	obj.AccountMetaSlice[0] = common.Meta(burnFrom).WRITE()
	return obj
}

// GetBurnFromAccount gets the "burnFrom" parameter.
// The account to burn from.
func (obj *Burn) GetBurnFromAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *Burn) SetMintAccount(mint common.PublicKey) *Burn {
	obj.AccountMetaSlice[1] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *Burn) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The account's owner/delegate.
func (obj *Burn) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *Burn {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The account's owner/delegate.
func (obj *Burn) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *Burn) SetProgramId(programId *common.PublicKey) *Burn {
	obj._programId = programId
	return obj
}

func (obj *Burn) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Burn}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Burn) Validate() error {
	if obj.Amount == nil {
		return errors.New("[Burn] amount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Burn] accounts.burnFrom is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Burn] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Burn] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Burn) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Burn) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Burn) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *Burn) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Burn")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Amount", *obj.Amount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta(" burnFrom", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// CloseAccount Instruction
type CloseAccount struct {
	// [0] = [WRITE] account `The account to close.`
	// [1] = [WRITE] destination `The destination account.`
	// [2] = [SIGNER] authority `The account's owner.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCloseAccountInstructionBuilder creates a new `CloseAccount` instruction builder.
func NewCloseAccountInstructionBuilder() *CloseAccount {
	return &CloseAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewCloseAccountInstruction
//
// Parameters:
//
//	account: The account to close.
//	destination: The destination account.
//	authority: The account's owner.
func NewCloseAccountInstruction(
	account common.PublicKey,
	destination common.PublicKey,
	authority common.PublicKey,
) *CloseAccount {
	return NewCloseAccountInstructionBuilder().
		SetAccountAccount(account).
		SetDestinationAccount(destination).
		SetAuthorityAccount(authority)
}

// SetAccountAccount sets the "account" parameter.
// The account to close.
func (obj *CloseAccount) SetAccountAccount(account common.PublicKey) *CloseAccount {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to close.
func (obj *CloseAccount) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDestinationAccount sets the "destination" parameter.
// The destination account.
func (obj *CloseAccount) SetDestinationAccount(destination common.PublicKey) *CloseAccount {
	obj.AccountMetaSlice[1] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// The destination account.
func (obj *CloseAccount) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The account's owner.
func (obj *CloseAccount) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *CloseAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The account's owner.
func (obj *CloseAccount) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *CloseAccount) SetProgramId(programId *common.PublicKey) *CloseAccount {
	obj._programId = programId
	return obj
}

func (obj *CloseAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CloseAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CloseAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CloseAccount] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CloseAccount] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CloseAccount] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CloseAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CloseAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CloseAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CloseAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CloseAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("    account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("destination", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// FreezeAccount Instruction
type FreezeAccount struct {
	// [0] = [WRITE] account `The account to freeze.`
	// [1] = [] mint `The token mint.`
	// [2] = [SIGNER] authority `The mint freeze authority.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewFreezeAccountInstructionBuilder creates a new `FreezeAccount` instruction builder.
func NewFreezeAccountInstructionBuilder() *FreezeAccount {
	return &FreezeAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewFreezeAccountInstruction
//
// Parameters:
//
//	account: The account to freeze.
//	mint: The token mint.
//	authority: The mint freeze authority.
func NewFreezeAccountInstruction(
	account common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
) *FreezeAccount {
	return NewFreezeAccountInstructionBuilder().
		SetAccountAccount(account).
		SetMintAccount(mint).
		SetAuthorityAccount(authority)
}

// SetAccountAccount sets the "account" parameter.
// The account to freeze.
func (obj *FreezeAccount) SetAccountAccount(account common.PublicKey) *FreezeAccount {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to freeze.
func (obj *FreezeAccount) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *FreezeAccount) SetMintAccount(mint common.PublicKey) *FreezeAccount {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *FreezeAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The mint freeze authority.
func (obj *FreezeAccount) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *FreezeAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The mint freeze authority.
func (obj *FreezeAccount) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *FreezeAccount) SetProgramId(programId *common.PublicKey) *FreezeAccount {
	obj._programId = programId
	return obj
}

func (obj *FreezeAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_FreezeAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *FreezeAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[FreezeAccount] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[FreezeAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[FreezeAccount] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *FreezeAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *FreezeAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *FreezeAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *FreezeAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("FreezeAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("  account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// ThawAccount Instruction
type ThawAccount struct {
	// [0] = [WRITE] account `The account to freeze.`
	// [1] = [] mint `The token mint.`
	// [2] = [SIGNER] authority `The mint freeze authority.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewThawAccountInstructionBuilder creates a new `ThawAccount` instruction builder.
func NewThawAccountInstructionBuilder() *ThawAccount {
	return &ThawAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewThawAccountInstruction
//
// Parameters:
//
//	account: The account to freeze.
//	mint: The token mint.
//	authority: The mint freeze authority.
func NewThawAccountInstruction(
	account common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
) *ThawAccount {
	return NewThawAccountInstructionBuilder().
		SetAccountAccount(account).
		SetMintAccount(mint).
		SetAuthorityAccount(authority)
}

// SetAccountAccount sets the "account" parameter.
// The account to freeze.
func (obj *ThawAccount) SetAccountAccount(account common.PublicKey) *ThawAccount {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to freeze.
func (obj *ThawAccount) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *ThawAccount) SetMintAccount(mint common.PublicKey) *ThawAccount {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *ThawAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The mint freeze authority.
func (obj *ThawAccount) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *ThawAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The mint freeze authority.
func (obj *ThawAccount) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *ThawAccount) SetProgramId(programId *common.PublicKey) *ThawAccount {
	obj._programId = programId
	return obj
}

func (obj *ThawAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ThawAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ThawAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ThawAccount] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ThawAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ThawAccount] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ThawAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ThawAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *ThawAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *ThawAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ThawAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("  account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// TransferChecked Instruction
type TransferChecked struct {
	Amount   *uint64
	Decimals *uint8
	// [0] = [WRITE] source `The source account.`
	// [1] = [] mint `The token mint.`
	// [2] = [WRITE] destination `The destination account.`
	// [3] = [SIGNER] authority `The source account's owner/delegate.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferCheckedInstructionBuilder creates a new `TransferChecked` instruction builder.
func NewTransferCheckedInstructionBuilder() *TransferChecked {
	return &TransferChecked{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewTransferCheckedInstruction
//
// Parameters:
//
//	amount:
//	decimals:
//	source: The source account.
//	mint: The token mint.
//	destination: The destination account.
//	authority: The source account's owner/delegate.
func NewTransferCheckedInstruction(
	amount uint64,
	decimals uint8,
	source common.PublicKey,
	mint common.PublicKey,
	destination common.PublicKey,
	authority common.PublicKey,
) *TransferChecked {
	return NewTransferCheckedInstructionBuilder().
		SetAmount(amount).
		SetDecimals(decimals).
		SetSourceAccount(source).
		SetMintAccount(mint).
		SetDestinationAccount(destination).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *TransferChecked) SetAmount(amount uint64) *TransferChecked {
	obj.Amount = &amount
	return obj
}

// SetDecimals sets the "decimals" parameter.
func (obj *TransferChecked) SetDecimals(decimals uint8) *TransferChecked {
	obj.Decimals = &decimals
	return obj
}

// SetSourceAccount sets the "source" parameter.
// The source account.
func (obj *TransferChecked) SetSourceAccount(source common.PublicKey) *TransferChecked {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// The source account.
func (obj *TransferChecked) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *TransferChecked) SetMintAccount(mint common.PublicKey) *TransferChecked {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *TransferChecked) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetDestinationAccount sets the "destination" parameter.
// The destination account.
func (obj *TransferChecked) SetDestinationAccount(destination common.PublicKey) *TransferChecked {
	obj.AccountMetaSlice[2] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// The destination account.
func (obj *TransferChecked) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetAuthorityAccount sets the "authority" parameter.
// The source account's owner/delegate.
func (obj *TransferChecked) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *TransferChecked {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The source account's owner/delegate.
func (obj *TransferChecked) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *TransferChecked) SetProgramId(programId *common.PublicKey) *TransferChecked {
	obj._programId = programId
	return obj
}

func (obj *TransferChecked) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_TransferChecked}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *TransferChecked) Validate() error {
	if obj.Amount == nil {
		return errors.New("[TransferChecked] amount param is not set")
	}
	if obj.Decimals == nil {
		return errors.New("[TransferChecked] decimals param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[TransferChecked] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[TransferChecked] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[TransferChecked] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[TransferChecked] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *TransferChecked) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *TransferChecked) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *TransferChecked) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *TransferChecked) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("TransferChecked")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("  Amount", *obj.Amount))
						paramsBranch.Child(format.Param("Decimals", *obj.Decimals))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("       mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("destination", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("  authority", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// ApproveChecked Instruction
type ApproveChecked struct {
	Amount   *uint64
	Decimals *uint64
	// [0] = [WRITE] source `The source account.`
	// [1] = [] mint `The token mint.`
	// [2] = [] delegate `The delegate.`
	// [3] = [SIGNER] authority `The source account owner.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewApproveCheckedInstructionBuilder creates a new `ApproveChecked` instruction builder.
func NewApproveCheckedInstructionBuilder() *ApproveChecked {
	return &ApproveChecked{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewApproveCheckedInstruction
//
// Parameters:
//
//	amount:
//	decimals:
//	source: The source account.
//	mint: The token mint.
//	delegate: The delegate.
//	authority: The source account owner.
func NewApproveCheckedInstruction(
	amount uint64,
	decimals uint64,
	source common.PublicKey,
	mint common.PublicKey,
	delegate common.PublicKey,
	authority common.PublicKey,
) *ApproveChecked {
	return NewApproveCheckedInstructionBuilder().
		SetAmount(amount).
		SetDecimals(decimals).
		SetSourceAccount(source).
		SetMintAccount(mint).
		SetDelegateAccount(delegate).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *ApproveChecked) SetAmount(amount uint64) *ApproveChecked {
	obj.Amount = &amount
	return obj
}

// SetDecimals sets the "decimals" parameter.
func (obj *ApproveChecked) SetDecimals(decimals uint64) *ApproveChecked {
	obj.Decimals = &decimals
	return obj
}

// SetSourceAccount sets the "source" parameter.
// The source account.
func (obj *ApproveChecked) SetSourceAccount(source common.PublicKey) *ApproveChecked {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// The source account.
func (obj *ApproveChecked) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *ApproveChecked) SetMintAccount(mint common.PublicKey) *ApproveChecked {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *ApproveChecked) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetDelegateAccount sets the "delegate" parameter.
// The delegate.
func (obj *ApproveChecked) SetDelegateAccount(delegate common.PublicKey) *ApproveChecked {
	obj.AccountMetaSlice[2] = common.Meta(delegate)
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// The delegate.
func (obj *ApproveChecked) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetAuthorityAccount sets the "authority" parameter.
// The source account owner.
func (obj *ApproveChecked) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *ApproveChecked {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The source account owner.
func (obj *ApproveChecked) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *ApproveChecked) SetProgramId(programId *common.PublicKey) *ApproveChecked {
	obj._programId = programId
	return obj
}

func (obj *ApproveChecked) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ApproveChecked}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ApproveChecked) Validate() error {
	if obj.Amount == nil {
		return errors.New("[ApproveChecked] amount param is not set")
	}
	if obj.Decimals == nil {
		return errors.New("[ApproveChecked] decimals param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ApproveChecked] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ApproveChecked] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ApproveChecked] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[ApproveChecked] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ApproveChecked) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ApproveChecked) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *ApproveChecked) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *ApproveChecked) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ApproveChecked")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("  Amount", *obj.Amount))
						paramsBranch.Child(format.Param("Decimals", *obj.Decimals))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("   source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta(" delegate", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// MintToChecked Instruction
type MintToChecked struct {
	Amount   *uint64
	Decimals *uint64
	// [0] = [WRITE] mint `The mint.`
	// [1] = [WRITE] to `The account to mint tokens to.`
	// [2] = [SIGNER] authority `The mint's minting authority.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMintToCheckedInstructionBuilder creates a new `MintToChecked` instruction builder.
func NewMintToCheckedInstructionBuilder() *MintToChecked {
	return &MintToChecked{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewMintToCheckedInstruction
//
// Parameters:
//
//	amount:
//	decimals:
//	mint: The mint.
//	to: The account to mint tokens to.
//	authority: The mint's minting authority.
func NewMintToCheckedInstruction(
	amount uint64,
	decimals uint64,
	mint common.PublicKey,
	to common.PublicKey,
	authority common.PublicKey,
) *MintToChecked {
	return NewMintToCheckedInstructionBuilder().
		SetAmount(amount).
		SetDecimals(decimals).
		SetMintAccount(mint).
		SetToAccount(to).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *MintToChecked) SetAmount(amount uint64) *MintToChecked {
	obj.Amount = &amount
	return obj
}

// SetDecimals sets the "decimals" parameter.
func (obj *MintToChecked) SetDecimals(decimals uint64) *MintToChecked {
	obj.Decimals = &decimals
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint.
func (obj *MintToChecked) SetMintAccount(mint common.PublicKey) *MintToChecked {
	obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint.
func (obj *MintToChecked) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetToAccount sets the "to" parameter.
// The account to mint tokens to.
func (obj *MintToChecked) SetToAccount(to common.PublicKey) *MintToChecked {
	obj.AccountMetaSlice[1] = common.Meta(to).WRITE()
	return obj
}

// GetToAccount gets the "to" parameter.
// The account to mint tokens to.
func (obj *MintToChecked) GetToAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The mint's minting authority.
func (obj *MintToChecked) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *MintToChecked {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The mint's minting authority.
func (obj *MintToChecked) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *MintToChecked) SetProgramId(programId *common.PublicKey) *MintToChecked {
	obj._programId = programId
	return obj
}

func (obj *MintToChecked) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MintToChecked}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MintToChecked) Validate() error {
	if obj.Amount == nil {
		return errors.New("[MintToChecked] amount param is not set")
	}
	if obj.Decimals == nil {
		return errors.New("[MintToChecked] decimals param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[MintToChecked] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[MintToChecked] accounts.to is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[MintToChecked] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MintToChecked) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MintToChecked) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *MintToChecked) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *MintToChecked) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MintToChecked")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("  Amount", *obj.Amount))
						paramsBranch.Child(format.Param("Decimals", *obj.Decimals))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("       to", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// BurnChecked Instruction
type BurnChecked struct {
	Amount   *uint64
	Decimals *uint64
	// [0] = [WRITE] burnFrom `The account to burn from.`
	// [1] = [WRITE] mint `The token mint.`
	// [2] = [SIGNER] authority `The account's owner/delegate.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBurnCheckedInstructionBuilder creates a new `BurnChecked` instruction builder.
func NewBurnCheckedInstructionBuilder() *BurnChecked {
	return &BurnChecked{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewBurnCheckedInstruction
//
// Parameters:
//
//	amount:
//	decimals:
//	burnFrom: The account to burn from.
//	mint: The token mint.
//	authority: The account's owner/delegate.
func NewBurnCheckedInstruction(
	amount uint64,
	decimals uint64,
	burnFrom common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
) *BurnChecked {
	return NewBurnCheckedInstructionBuilder().
		SetAmount(amount).
		SetDecimals(decimals).
		SetBurnFromAccount(burnFrom).
		SetMintAccount(mint).
		SetAuthorityAccount(authority)
}

// SetAmount sets the "amount" parameter.
func (obj *BurnChecked) SetAmount(amount uint64) *BurnChecked {
	obj.Amount = &amount
	return obj
}

// SetDecimals sets the "decimals" parameter.
func (obj *BurnChecked) SetDecimals(decimals uint64) *BurnChecked {
	obj.Decimals = &decimals
	return obj
}

// SetBurnFromAccount sets the "burnFrom" parameter.
// The account to burn from.
func (obj *BurnChecked) SetBurnFromAccount(burnFrom common.PublicKey) *BurnChecked {
	obj.AccountMetaSlice[0] = common.Meta(burnFrom).WRITE()
	return obj
}

// GetBurnFromAccount gets the "burnFrom" parameter.
// The account to burn from.
func (obj *BurnChecked) GetBurnFromAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The token mint.
func (obj *BurnChecked) SetMintAccount(mint common.PublicKey) *BurnChecked {
	obj.AccountMetaSlice[1] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint.
func (obj *BurnChecked) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// The account's owner/delegate.
func (obj *BurnChecked) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *BurnChecked {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// The account's owner/delegate.
func (obj *BurnChecked) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *BurnChecked) SetProgramId(programId *common.PublicKey) *BurnChecked {
	obj._programId = programId
	return obj
}

func (obj *BurnChecked) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_BurnChecked}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *BurnChecked) Validate() error {
	if obj.Amount == nil {
		return errors.New("[BurnChecked] amount param is not set")
	}
	if obj.Decimals == nil {
		return errors.New("[BurnChecked] decimals param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[BurnChecked] accounts.burnFrom is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[BurnChecked] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[BurnChecked] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *BurnChecked) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *BurnChecked) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *BurnChecked) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	return nil
}

func (obj *BurnChecked) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("BurnChecked")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=2]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("  Amount", *obj.Amount))
						paramsBranch.Child(format.Param("Decimals", *obj.Decimals))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta(" burnFrom", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// InitializeAccount2 Instruction
type InitializeAccount2 struct {
	Owner *common.PublicKey
	// [0] = [WRITE] account `The account to initialize.`
	// [1] = [] mint `The mint this account will be associated with.`
	// [2] = [] rent `Rent sysvar`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeAccount2InstructionBuilder creates a new `InitializeAccount2` instruction builder.
func NewInitializeAccount2InstructionBuilder() *InitializeAccount2 {
	return &InitializeAccount2{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewInitializeAccount2Instruction
//
// Parameters:
//
//	owner:
//	account: The account to initialize.
//	mint: The mint this account will be associated with.
//	rent: Rent sysvar
func NewInitializeAccount2Instruction(
	owner common.PublicKey,
	account common.PublicKey,
	mint common.PublicKey,
	rent common.PublicKey,
) *InitializeAccount2 {
	return NewInitializeAccount2InstructionBuilder().
		SetOwner(owner).
		SetAccountAccount(account).
		SetMintAccount(mint).
		SetRentAccount(rent)
}

// SetOwner sets the "owner" parameter.
func (obj *InitializeAccount2) SetOwner(owner common.PublicKey) *InitializeAccount2 {
	obj.Owner = &owner
	return obj
}

// SetAccountAccount sets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount2) SetAccountAccount(account common.PublicKey) *InitializeAccount2 {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount2) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount2) SetMintAccount(mint common.PublicKey) *InitializeAccount2 {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount2) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetRentAccount sets the "rent" parameter.
// Rent sysvar
func (obj *InitializeAccount2) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *InitializeAccount2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent sysvar
func (obj *InitializeAccount2) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *InitializeAccount2) SetProgramId(programId *common.PublicKey) *InitializeAccount2 {
	obj._programId = programId
	return obj
}

func (obj *InitializeAccount2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeAccount2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeAccount2) Validate() error {
	if obj.Owner == nil {
		return errors.New("[InitializeAccount2] owner param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeAccount2] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeAccount2] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[InitializeAccount2] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeAccount2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeAccount2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Owner); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeAccount2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Owner); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeAccount2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeAccount2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Owner", *obj.Owner))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("   rent", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// SyncNative Instruction
type SyncNative struct {
	// [0] = [WRITE] account `The native token account to sync with its underlying lamports.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSyncNativeInstructionBuilder creates a new `SyncNative` instruction builder.
func NewSyncNativeInstructionBuilder() *SyncNative {
	return &SyncNative{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewSyncNativeInstruction
//
// Parameters:
//
//	account: The native token account to sync with its underlying lamports.
func NewSyncNativeInstruction(
	account common.PublicKey,
) *SyncNative {
	return NewSyncNativeInstructionBuilder().
		SetAccountAccount(account)
}

// SetAccountAccount sets the "account" parameter.
// The native token account to sync with its underlying lamports.
func (obj *SyncNative) SetAccountAccount(account common.PublicKey, multiSigners ...common.PublicKey) *SyncNative {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(account)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	}
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The native token account to sync with its underlying lamports.
func (obj *SyncNative) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *SyncNative) SetProgramId(programId *common.PublicKey) *SyncNative {
	obj._programId = programId
	return obj
}

func (obj *SyncNative) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SyncNative}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SyncNative) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SyncNative] accounts.account is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SyncNative) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SyncNative) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SyncNative) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *SyncNative) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SyncNative")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// InitializeAccount3 Instruction
type InitializeAccount3 struct {
	Owner *common.PublicKey
	// [0] = [WRITE] account `The account to initialize.`
	// [1] = [] mint `The mint this account will be associated with.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeAccount3InstructionBuilder creates a new `InitializeAccount3` instruction builder.
func NewInitializeAccount3InstructionBuilder() *InitializeAccount3 {
	return &InitializeAccount3{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewInitializeAccount3Instruction
//
// Parameters:
//
//	owner:
//	account: The account to initialize.
//	mint: The mint this account will be associated with.
func NewInitializeAccount3Instruction(
	owner common.PublicKey,
	account common.PublicKey,
	mint common.PublicKey,
) *InitializeAccount3 {
	return NewInitializeAccount3InstructionBuilder().
		SetOwner(owner).
		SetAccountAccount(account).
		SetMintAccount(mint)
}

// SetOwner sets the "owner" parameter.
func (obj *InitializeAccount3) SetOwner(owner common.PublicKey) *InitializeAccount3 {
	obj.Owner = &owner
	return obj
}

// SetAccountAccount sets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount3) SetAccountAccount(account common.PublicKey) *InitializeAccount3 {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to initialize.
func (obj *InitializeAccount3) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount3) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *InitializeAccount3 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(mint)
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint this account will be associated with.
func (obj *InitializeAccount3) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *InitializeAccount3) SetProgramId(programId *common.PublicKey) *InitializeAccount3 {
	obj._programId = programId
	return obj
}

func (obj *InitializeAccount3) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeAccount3}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeAccount3) Validate() error {
	if obj.Owner == nil {
		return errors.New("[InitializeAccount3] owner param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeAccount3] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[InitializeAccount3] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeAccount3) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeAccount3) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Owner); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeAccount3) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Owner); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeAccount3) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeAccount3")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Owner", *obj.Owner))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   mint", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// InitializeMultisig2 Instruction
type InitializeMultisig2 struct {
	M *uint8
	// [0] = [WRITE] account `The multisignature account to initialize.,..1+N. `[]` The signer accounts, must equal to N where 1 <= N <= 11.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMultisig2InstructionBuilder creates a new `InitializeMultisig2` instruction builder.
func NewInitializeMultisig2InstructionBuilder() *InitializeMultisig2 {
	return &InitializeMultisig2{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializeMultisig2Instruction
//
// Parameters:
//   m:
/*
  account: The multisignature account to initialize.
  ..1+N. `[]` The signer accounts, must equal to N where 1 <= N <= 11.
*/
//
func NewInitializeMultisig2Instruction(
	m uint8,
	account common.PublicKey,
) *InitializeMultisig2 {
	return NewInitializeMultisig2InstructionBuilder().
		SetM(m).
		SetAccountAccount(account)
}

// SetM sets the "m" parameter.
func (obj *InitializeMultisig2) SetM(m uint8) *InitializeMultisig2 {
	obj.M = &m
	return obj
}

// SetAccountAccount sets the "account" parameter.
// The multisignature account to initialize.
// ..1+N. `[]` The signer accounts, must equal to N where 1 <= N <= 11.
func (obj *InitializeMultisig2) SetAccountAccount(account common.PublicKey, multiSigners ...common.PublicKey) *InitializeMultisig2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(account)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	}
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The multisignature account to initialize.
// ..1+N. `[]` The signer accounts, must equal to N where 1 <= N <= 11.
func (obj *InitializeMultisig2) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializeMultisig2) SetProgramId(programId *common.PublicKey) *InitializeMultisig2 {
	obj._programId = programId
	return obj
}

func (obj *InitializeMultisig2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeMultisig2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeMultisig2) Validate() error {
	if obj.M == nil {
		return errors.New("[InitializeMultisig2] m param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMultisig2] accounts.account is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMultisig2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMultisig2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.M); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeMultisig2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.M); err != nil {
		return err
	}
	return nil
}

func (obj *InitializeMultisig2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMultisig2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("M", *obj.M))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// InitializeMint2 Instruction
type InitializeMint2 struct {
	Decimals        *uint8
	Authority       *common.PublicKey
	FreezeAuthority *common.PublicKey `bin:"optional"`
	// [0] = [WRITE] mint `The mint to initialize.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMint2InstructionBuilder creates a new `InitializeMint2` instruction builder.
func NewInitializeMint2InstructionBuilder() *InitializeMint2 {
	return &InitializeMint2{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializeMint2Instruction
//
// Parameters:
//
//	decimals:
//	authority:
//	freezeAuthority:
//	mint: The mint to initialize.
func NewInitializeMint2Instruction(
	decimals uint8,
	authority common.PublicKey,
	// optional,
	freezeAuthority *common.PublicKey,
	mint common.PublicKey,
) *InitializeMint2 {
	return NewInitializeMint2InstructionBuilder().
		SetDecimals(decimals).
		SetAuthority(authority).
		SetFreezeAuthority(freezeAuthority).
		SetMintAccount(mint)
}

// SetDecimals sets the "decimals" parameter.
func (obj *InitializeMint2) SetDecimals(decimals uint8) *InitializeMint2 {
	obj.Decimals = &decimals
	return obj
}

// SetAuthority sets the "authority" parameter.
func (obj *InitializeMint2) SetAuthority(authority common.PublicKey) *InitializeMint2 {
	obj.Authority = &authority
	return obj
}

// SetFreezeAuthority sets the "freezeAuthority" parameter.
func (obj *InitializeMint2) SetFreezeAuthority(freezeAuthority *common.PublicKey) *InitializeMint2 {
	obj.FreezeAuthority = freezeAuthority
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMint2) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *InitializeMint2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMint2) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializeMint2) SetProgramId(programId *common.PublicKey) *InitializeMint2 {
	obj._programId = programId
	return obj
}

func (obj *InitializeMint2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeMint2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeMint2) Validate() error {
	if obj.Decimals == nil {
		return errors.New("[InitializeMint2] decimals param is not set")
	}
	if obj.Authority == nil {
		return errors.New("[InitializeMint2] authority param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMint2] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMint2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMint2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Decimals); err != nil {
		return err
	}
	if err = encoder.Encode(&obj.Authority); err != nil {
		return err
	}
	if err = encoder.WriteBool(obj.FreezeAuthority != nil); err != nil {
		return err
	}
	if obj.FreezeAuthority != nil {
		if err = encoder.Encode(obj.FreezeAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMint2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return err
	}
	if err = decoder.Decode(&obj.Authority); err != nil {
		return err
	}
	if ok, err := decoder.ReadBool(); err != nil {
		return err
	} else if ok {
		if err = decoder.Decode(&obj.FreezeAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMint2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMint2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=3]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("       Decimals", *obj.Decimals))
						paramsBranch.Child(format.Param("      Authority", *obj.Authority))
						paramsBranch.Child(format.Param("FreezeAuthority (OPT)", obj.FreezeAuthority))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// GetAccountDataSize Instruction
type GetAccountDataSize struct {
	ExtensionTypes []ExtensionType
	// [0] = [] mint `The mint to calculate for`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewGetAccountDataSizeInstructionBuilder creates a new `GetAccountDataSize` instruction builder.
func NewGetAccountDataSizeInstructionBuilder() *GetAccountDataSize {
	return &GetAccountDataSize{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewGetAccountDataSizeInstruction
//
// Parameters:
//
//	extensionTypes:
//	mint: The mint to calculate for
func NewGetAccountDataSizeInstruction(
	extensionTypes []ExtensionType,
	mint common.PublicKey,
) *GetAccountDataSize {
	return NewGetAccountDataSizeInstructionBuilder().
		SetExtensionTypes(extensionTypes).
		SetMintAccount(mint)
}

// SetExtensionTypes sets the "extensionTypes" parameter.
func (obj *GetAccountDataSize) SetExtensionTypes(extensionTypes []ExtensionType) *GetAccountDataSize {
	obj.ExtensionTypes = extensionTypes
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to calculate for
func (obj *GetAccountDataSize) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *GetAccountDataSize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint)
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to calculate for
func (obj *GetAccountDataSize) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *GetAccountDataSize) SetProgramId(programId *common.PublicKey) *GetAccountDataSize {
	obj._programId = programId
	return obj
}

func (obj *GetAccountDataSize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_GetAccountDataSize}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *GetAccountDataSize) Validate() error {
	if obj.ExtensionTypes == nil {
		return errors.New("[GetAccountDataSize] extensionTypes param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[GetAccountDataSize] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *GetAccountDataSize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *GetAccountDataSize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.ExtensionTypes); err != nil {
		return err
	}
	return nil
}

func (obj *GetAccountDataSize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.ExtensionTypes); err != nil {
		return err
	}
	return nil
}

func (obj *GetAccountDataSize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("GetAccountDataSize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("ExtensionTypes", obj.ExtensionTypes))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// InitializeImmutableOwner Instruction
type InitializeImmutableOwner struct {
	// [0] = [WRITE] account `The account to initialize.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeImmutableOwnerInstructionBuilder creates a new `InitializeImmutableOwner` instruction builder.
func NewInitializeImmutableOwnerInstructionBuilder() *InitializeImmutableOwner {
	return &InitializeImmutableOwner{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializeImmutableOwnerInstruction
//
// Parameters:
//
//	account: The account to initialize.
func NewInitializeImmutableOwnerInstruction(
	account common.PublicKey,
) *InitializeImmutableOwner {
	return NewInitializeImmutableOwnerInstructionBuilder().
		SetAccountAccount(account)
}

// SetAccountAccount sets the "account" parameter.
// The account to initialize.
func (obj *InitializeImmutableOwner) SetAccountAccount(account common.PublicKey, multiSigners ...common.PublicKey) *InitializeImmutableOwner {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(account)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	}
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to initialize.
func (obj *InitializeImmutableOwner) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializeImmutableOwner) SetProgramId(programId *common.PublicKey) *InitializeImmutableOwner {
	obj._programId = programId
	return obj
}

func (obj *InitializeImmutableOwner) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeImmutableOwner}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeImmutableOwner) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeImmutableOwner] accounts.account is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeImmutableOwner) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeImmutableOwner) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *InitializeImmutableOwner) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *InitializeImmutableOwner) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeImmutableOwner")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("account", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// AmountToUiAmount Instruction
type AmountToUiAmount struct {
	Amount *uint64
	// [0] = [] mint `The mint to calculate for`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewAmountToUiAmountInstructionBuilder creates a new `AmountToUiAmount` instruction builder.
func NewAmountToUiAmountInstructionBuilder() *AmountToUiAmount {
	return &AmountToUiAmount{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewAmountToUiAmountInstruction
//
// Parameters:
//
//	amount:
//	mint: The mint to calculate for
func NewAmountToUiAmountInstruction(
	amount uint64,
	mint common.PublicKey,
) *AmountToUiAmount {
	return NewAmountToUiAmountInstructionBuilder().
		SetAmount(amount).
		SetMintAccount(mint)
}

// SetAmount sets the "amount" parameter.
func (obj *AmountToUiAmount) SetAmount(amount uint64) *AmountToUiAmount {
	obj.Amount = &amount
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to calculate for
func (obj *AmountToUiAmount) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *AmountToUiAmount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint)
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to calculate for
func (obj *AmountToUiAmount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *AmountToUiAmount) SetProgramId(programId *common.PublicKey) *AmountToUiAmount {
	obj._programId = programId
	return obj
}

func (obj *AmountToUiAmount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_AmountToUiAmount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *AmountToUiAmount) Validate() error {
	if obj.Amount == nil {
		return errors.New("[AmountToUiAmount] amount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[AmountToUiAmount] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *AmountToUiAmount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *AmountToUiAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *AmountToUiAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Amount); err != nil {
		return err
	}
	return nil
}

func (obj *AmountToUiAmount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("AmountToUiAmount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Amount", *obj.Amount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// UiAmountToAmount Instruction
type UiAmountToAmount struct {
	UiAmount *string
	// [0] = [] mint `The mint to calculate for`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUiAmountToAmountInstructionBuilder creates a new `UiAmountToAmount` instruction builder.
func NewUiAmountToAmountInstructionBuilder() *UiAmountToAmount {
	return &UiAmountToAmount{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewUiAmountToAmountInstruction
//
// Parameters:
//
//	uiAmount:
//	mint: The mint to calculate for
func NewUiAmountToAmountInstruction(
	uiAmount string,
	mint common.PublicKey,
) *UiAmountToAmount {
	return NewUiAmountToAmountInstructionBuilder().
		SetUiAmount(uiAmount).
		SetMintAccount(mint)
}

// SetUiAmount sets the "uiAmount" parameter.
func (obj *UiAmountToAmount) SetUiAmount(uiAmount string) *UiAmountToAmount {
	obj.UiAmount = &uiAmount
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to calculate for
func (obj *UiAmountToAmount) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *UiAmountToAmount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint)
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to calculate for
func (obj *UiAmountToAmount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *UiAmountToAmount) SetProgramId(programId *common.PublicKey) *UiAmountToAmount {
	obj._programId = programId
	return obj
}

func (obj *UiAmountToAmount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UiAmountToAmount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UiAmountToAmount) Validate() error {
	if obj.UiAmount == nil {
		return errors.New("[UiAmountToAmount] uiAmount param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UiAmountToAmount] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UiAmountToAmount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UiAmountToAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes([]byte(*obj.UiAmount), false); err != nil {
		return err
	}
	return nil
}

func (obj *UiAmountToAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UiAmount); err != nil {
		return err
	}
	return nil
}

func (obj *UiAmountToAmount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UiAmountToAmount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UiAmount", *obj.UiAmount))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// InitializeMintCloseAuthority Instruction
type InitializeMintCloseAuthority struct {
	CloseAuthority *common.PublicKey `bin:"optional"`
	// [0] = [WRITE] mint `The mint to initialize.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeMintCloseAuthorityInstructionBuilder creates a new `InitializeMintCloseAuthority` instruction builder.
func NewInitializeMintCloseAuthorityInstructionBuilder() *InitializeMintCloseAuthority {
	return &InitializeMintCloseAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializeMintCloseAuthorityInstruction
//
// Parameters:
//
//	closeAuthority:
//	mint: The mint to initialize.
func NewInitializeMintCloseAuthorityInstruction(
	// optional,
	closeAuthority *common.PublicKey,
	mint common.PublicKey,
) *InitializeMintCloseAuthority {
	return NewInitializeMintCloseAuthorityInstructionBuilder().
		SetCloseAuthority(closeAuthority).
		SetMintAccount(mint)
}

// SetCloseAuthority sets the "closeAuthority" parameter.
func (obj *InitializeMintCloseAuthority) SetCloseAuthority(closeAuthority *common.PublicKey) *InitializeMintCloseAuthority {
	obj.CloseAuthority = closeAuthority
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMintCloseAuthority) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *InitializeMintCloseAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to initialize.
func (obj *InitializeMintCloseAuthority) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializeMintCloseAuthority) SetProgramId(programId *common.PublicKey) *InitializeMintCloseAuthority {
	obj._programId = programId
	return obj
}

func (obj *InitializeMintCloseAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeMintCloseAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeMintCloseAuthority) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeMintCloseAuthority] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeMintCloseAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeMintCloseAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBool(obj.CloseAuthority != nil); err != nil {
		return err
	}
	if obj.CloseAuthority != nil {
		if err = encoder.Encode(obj.CloseAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMintCloseAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if ok, err := decoder.ReadBool(); err != nil {
		return err
	} else if ok {
		if err = decoder.Decode(&obj.CloseAuthority); err != nil {
			return err
		}
	}
	return nil
}

func (obj *InitializeMintCloseAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeMintCloseAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("CloseAuthority (OPT)", obj.CloseAuthority))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// TransferFeeExtension Instruction
type TransferFeeExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferFeeExtensionInstructionBuilder creates a new `TransferFeeExtension` instruction builder.
func NewTransferFeeExtensionInstructionBuilder() *TransferFeeExtension {
	return &TransferFeeExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewTransferFeeExtensionInstruction
//
// Parameters:
//
//	data:
func NewTransferFeeExtensionInstruction(
	data []byte,
) *TransferFeeExtension {
	return NewTransferFeeExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *TransferFeeExtension) SetData(data []byte) *TransferFeeExtension {
	obj.Data = data
	return obj
}

func (obj *TransferFeeExtension) SetProgramId(programId *common.PublicKey) *TransferFeeExtension {
	obj._programId = programId
	return obj
}

func (obj *TransferFeeExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_TransferFeeExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *TransferFeeExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[TransferFeeExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *TransferFeeExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *TransferFeeExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *TransferFeeExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *TransferFeeExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("TransferFeeExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// ConfidentialTransferExtension Instruction
type ConfidentialTransferExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewConfidentialTransferExtensionInstructionBuilder creates a new `ConfidentialTransferExtension` instruction builder.
func NewConfidentialTransferExtensionInstructionBuilder() *ConfidentialTransferExtension {
	return &ConfidentialTransferExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewConfidentialTransferExtensionInstruction
//
// Parameters:
//
//	data:
func NewConfidentialTransferExtensionInstruction(
	data []byte,
) *ConfidentialTransferExtension {
	return NewConfidentialTransferExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *ConfidentialTransferExtension) SetData(data []byte) *ConfidentialTransferExtension {
	obj.Data = data
	return obj
}

func (obj *ConfidentialTransferExtension) SetProgramId(programId *common.PublicKey) *ConfidentialTransferExtension {
	obj._programId = programId
	return obj
}

func (obj *ConfidentialTransferExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ConfidentialTransferExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ConfidentialTransferExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[ConfidentialTransferExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ConfidentialTransferExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ConfidentialTransferExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *ConfidentialTransferExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *ConfidentialTransferExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ConfidentialTransferExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// DefaultAccountStateExtension Instruction
type DefaultAccountStateExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDefaultAccountStateExtensionInstructionBuilder creates a new `DefaultAccountStateExtension` instruction builder.
func NewDefaultAccountStateExtensionInstructionBuilder() *DefaultAccountStateExtension {
	return &DefaultAccountStateExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewDefaultAccountStateExtensionInstruction
//
// Parameters:
//
//	data:
func NewDefaultAccountStateExtensionInstruction(
	data []byte,
) *DefaultAccountStateExtension {
	return NewDefaultAccountStateExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *DefaultAccountStateExtension) SetData(data []byte) *DefaultAccountStateExtension {
	obj.Data = data
	return obj
}

func (obj *DefaultAccountStateExtension) SetProgramId(programId *common.PublicKey) *DefaultAccountStateExtension {
	obj._programId = programId
	return obj
}

func (obj *DefaultAccountStateExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DefaultAccountStateExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DefaultAccountStateExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[DefaultAccountStateExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DefaultAccountStateExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DefaultAccountStateExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *DefaultAccountStateExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *DefaultAccountStateExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DefaultAccountStateExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// Reallocate Instruction
type Reallocate struct {
	// [0] = [WRITE] account `The account to reallocate.`
	// [1] = [WRITE, SIGNER] payer `The payer account to fund reallocation`
	// [2] = [] system `System program for reallocation funding`
	// [3] = [SIGNER] accountOwner `The account's owner.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewReallocateInstructionBuilder creates a new `Reallocate` instruction builder.
func NewReallocateInstructionBuilder() *Reallocate {
	return &Reallocate{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewReallocateInstruction
//
// Parameters:
//
//	account: The account to reallocate.
//	payer: The payer account to fund reallocation
//	system: System program for reallocation funding
//	accountOwner: The account's owner.
func NewReallocateInstruction(
	account common.PublicKey,
	payer common.PublicKey,
	system common.PublicKey,
	accountOwner common.PublicKey,
) *Reallocate {
	return NewReallocateInstructionBuilder().
		SetAccountAccount(account).
		SetPayerAccount(payer).
		SetSystemAccount(system).
		SetAccountOwnerAccount(accountOwner)
}

// SetAccountAccount sets the "account" parameter.
// The account to reallocate.
func (obj *Reallocate) SetAccountAccount(account common.PublicKey) *Reallocate {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// The account to reallocate.
func (obj *Reallocate) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetPayerAccount sets the "payer" parameter.
// The payer account to fund reallocation
func (obj *Reallocate) SetPayerAccount(payer common.PublicKey) *Reallocate {
	obj.AccountMetaSlice[1] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// The payer account to fund reallocation
func (obj *Reallocate) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetSystemAccount sets the "system" parameter.
// System program for reallocation funding
func (obj *Reallocate) SetSystemAccount(system common.PublicKey) *Reallocate {
	obj.AccountMetaSlice[2] = common.Meta(system)
	return obj
}

// GetSystemAccount gets the "system" parameter.
// System program for reallocation funding
func (obj *Reallocate) GetSystemAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetAccountOwnerAccount sets the "accountOwner" parameter.
// The account's owner.
func (obj *Reallocate) SetAccountOwnerAccount(accountOwner common.PublicKey, multiSigners ...common.PublicKey) *Reallocate {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(accountOwner)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(accountOwner).SIGNER()
	}
	return obj
}

// GetAccountOwnerAccount gets the "accountOwner" parameter.
// The account's owner.
func (obj *Reallocate) GetAccountOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *Reallocate) SetProgramId(programId *common.PublicKey) *Reallocate {
	obj._programId = programId
	return obj
}

func (obj *Reallocate) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Reallocate}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Reallocate) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Reallocate] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Reallocate] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Reallocate] accounts.system is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Reallocate] accounts.accountOwner is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Reallocate) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Reallocate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *Reallocate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *Reallocate) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Reallocate")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("       payer", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("      system", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("accountOwner", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// MemoTransferExtension Instruction
type MemoTransferExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMemoTransferExtensionInstructionBuilder creates a new `MemoTransferExtension` instruction builder.
func NewMemoTransferExtensionInstructionBuilder() *MemoTransferExtension {
	return &MemoTransferExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewMemoTransferExtensionInstruction
//
// Parameters:
//
//	data:
func NewMemoTransferExtensionInstruction(
	data []byte,
) *MemoTransferExtension {
	return NewMemoTransferExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *MemoTransferExtension) SetData(data []byte) *MemoTransferExtension {
	obj.Data = data
	return obj
}

func (obj *MemoTransferExtension) SetProgramId(programId *common.PublicKey) *MemoTransferExtension {
	obj._programId = programId
	return obj
}

func (obj *MemoTransferExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MemoTransferExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MemoTransferExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[MemoTransferExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MemoTransferExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MemoTransferExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *MemoTransferExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *MemoTransferExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MemoTransferExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// CreateNativeMint Instruction
type CreateNativeMint struct {
	// [0] = [WRITE, SIGNER] funding 
	// [1] = [WRITE] nativeMint 
	// [2] = [] system 
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateNativeMintInstructionBuilder creates a new `CreateNativeMint` instruction builder.
func NewCreateNativeMintInstructionBuilder() *CreateNativeMint {
	return &CreateNativeMint{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewCreateNativeMintInstruction
//
// Parameters:
//
//	funding:
//	nativeMint:
//	system:
func NewCreateNativeMintInstruction(
	funding common.PublicKey,
	nativeMint common.PublicKey,
	system common.PublicKey,
) *CreateNativeMint {
	return NewCreateNativeMintInstructionBuilder().
		SetFundingAccount(funding).
		SetNativeMintAccount(nativeMint).
		SetSystemAccount(system)
}

// SetFundingAccount sets the "funding" parameter.
func (obj *CreateNativeMint) SetFundingAccount(funding common.PublicKey) *CreateNativeMint {
	obj.AccountMetaSlice[0] = common.Meta(funding).WRITE().SIGNER()
	return obj
}

// GetFundingAccount gets the "funding" parameter.
func (obj *CreateNativeMint) GetFundingAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetNativeMintAccount sets the "nativeMint" parameter.
func (obj *CreateNativeMint) SetNativeMintAccount(nativeMint common.PublicKey) *CreateNativeMint {
	obj.AccountMetaSlice[1] = common.Meta(nativeMint).WRITE()
	return obj
}

// GetNativeMintAccount gets the "nativeMint" parameter.
func (obj *CreateNativeMint) GetNativeMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetSystemAccount sets the "system" parameter.
func (obj *CreateNativeMint) SetSystemAccount(system common.PublicKey, multiSigners ...common.PublicKey) *CreateNativeMint {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(system)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(system)
	}
	return obj
}

// GetSystemAccount gets the "system" parameter.
func (obj *CreateNativeMint) GetSystemAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *CreateNativeMint) SetProgramId(programId *common.PublicKey) *CreateNativeMint {
	obj._programId = programId
	return obj
}

func (obj *CreateNativeMint) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateNativeMint}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateNativeMint) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateNativeMint] accounts.funding is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateNativeMint] accounts.nativeMint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateNativeMint] accounts.system is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateNativeMint) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateNativeMint) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateNativeMint) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateNativeMint) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateNativeMint")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("   funding", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("nativeMint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("    system", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// InitializeNonTransferableMint Instruction
type InitializeNonTransferableMint struct {
	// [0] = [WRITE] mint `The mint account to initialize.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializeNonTransferableMintInstructionBuilder creates a new `InitializeNonTransferableMint` instruction builder.
func NewInitializeNonTransferableMintInstructionBuilder() *InitializeNonTransferableMint {
	return &InitializeNonTransferableMint{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializeNonTransferableMintInstruction
//
// Parameters:
//
//	mint: The mint account to initialize.
func NewInitializeNonTransferableMintInstruction(
	mint common.PublicKey,
) *InitializeNonTransferableMint {
	return NewInitializeNonTransferableMintInstructionBuilder().
		SetMintAccount(mint)
}

// SetMintAccount sets the "mint" parameter.
// The mint account to initialize.
func (obj *InitializeNonTransferableMint) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *InitializeNonTransferableMint {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint account to initialize.
func (obj *InitializeNonTransferableMint) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializeNonTransferableMint) SetProgramId(programId *common.PublicKey) *InitializeNonTransferableMint {
	obj._programId = programId
	return obj
}

func (obj *InitializeNonTransferableMint) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializeNonTransferableMint}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializeNonTransferableMint) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializeNonTransferableMint] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializeNonTransferableMint) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializeNonTransferableMint) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *InitializeNonTransferableMint) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *InitializeNonTransferableMint) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializeNonTransferableMint")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// InterestBearingMintExtension Instruction
type InterestBearingMintExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInterestBearingMintExtensionInstructionBuilder creates a new `InterestBearingMintExtension` instruction builder.
func NewInterestBearingMintExtensionInstructionBuilder() *InterestBearingMintExtension {
	return &InterestBearingMintExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewInterestBearingMintExtensionInstruction
//
// Parameters:
//
//	data:
func NewInterestBearingMintExtensionInstruction(
	data []byte,
) *InterestBearingMintExtension {
	return NewInterestBearingMintExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *InterestBearingMintExtension) SetData(data []byte) *InterestBearingMintExtension {
	obj.Data = data
	return obj
}

func (obj *InterestBearingMintExtension) SetProgramId(programId *common.PublicKey) *InterestBearingMintExtension {
	obj._programId = programId
	return obj
}

func (obj *InterestBearingMintExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InterestBearingMintExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InterestBearingMintExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[InterestBearingMintExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InterestBearingMintExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InterestBearingMintExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *InterestBearingMintExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *InterestBearingMintExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InterestBearingMintExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// CpiGuardExtension Instruction
type CpiGuardExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCpiGuardExtensionInstructionBuilder creates a new `CpiGuardExtension` instruction builder.
func NewCpiGuardExtensionInstructionBuilder() *CpiGuardExtension {
	return &CpiGuardExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewCpiGuardExtensionInstruction
//
// Parameters:
//
//	data:
func NewCpiGuardExtensionInstruction(
	data []byte,
) *CpiGuardExtension {
	return NewCpiGuardExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *CpiGuardExtension) SetData(data []byte) *CpiGuardExtension {
	obj.Data = data
	return obj
}

func (obj *CpiGuardExtension) SetProgramId(programId *common.PublicKey) *CpiGuardExtension {
	obj._programId = programId
	return obj
}

func (obj *CpiGuardExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CpiGuardExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CpiGuardExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[CpiGuardExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CpiGuardExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CpiGuardExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *CpiGuardExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *CpiGuardExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CpiGuardExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// InitializePermanentDelegate Instruction
type InitializePermanentDelegate struct {
	Delegate *common.PublicKey
	// [0] = [WRITE] mint `The mint to initialize.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewInitializePermanentDelegateInstructionBuilder creates a new `InitializePermanentDelegate` instruction builder.
func NewInitializePermanentDelegateInstructionBuilder() *InitializePermanentDelegate {
	return &InitializePermanentDelegate{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewInitializePermanentDelegateInstruction
//
// Parameters:
//
//	delegate:
//	mint: The mint to initialize.
func NewInitializePermanentDelegateInstruction(
	delegate common.PublicKey,
	mint common.PublicKey,
) *InitializePermanentDelegate {
	return NewInitializePermanentDelegateInstructionBuilder().
		SetDelegate(delegate).
		SetMintAccount(mint)
}

// SetDelegate sets the "delegate" parameter.
func (obj *InitializePermanentDelegate) SetDelegate(delegate common.PublicKey) *InitializePermanentDelegate {
	obj.Delegate = &delegate
	return obj
}

// SetMintAccount sets the "mint" parameter.
// The mint to initialize.
func (obj *InitializePermanentDelegate) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *InitializePermanentDelegate {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(mint).WRITE()
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The mint to initialize.
func (obj *InitializePermanentDelegate) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *InitializePermanentDelegate) SetProgramId(programId *common.PublicKey) *InitializePermanentDelegate {
	obj._programId = programId
	return obj
}

func (obj *InitializePermanentDelegate) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_InitializePermanentDelegate}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *InitializePermanentDelegate) Validate() error {
	if obj.Delegate == nil {
		return errors.New("[InitializePermanentDelegate] delegate param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[InitializePermanentDelegate] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *InitializePermanentDelegate) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *InitializePermanentDelegate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.Delegate); err != nil {
		return err
	}
	return nil
}

func (obj *InitializePermanentDelegate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.Delegate); err != nil {
		return err
	}
	return nil
}

func (obj *InitializePermanentDelegate) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("InitializePermanentDelegate")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Delegate", *obj.Delegate))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("mint", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// TransferHookExtension Instruction
type TransferHookExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferHookExtensionInstructionBuilder creates a new `TransferHookExtension` instruction builder.
func NewTransferHookExtensionInstructionBuilder() *TransferHookExtension {
	return &TransferHookExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewTransferHookExtensionInstruction
//
// Parameters:
//
//	data:
func NewTransferHookExtensionInstruction(
	data []byte,
) *TransferHookExtension {
	return NewTransferHookExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *TransferHookExtension) SetData(data []byte) *TransferHookExtension {
	obj.Data = data
	return obj
}

func (obj *TransferHookExtension) SetProgramId(programId *common.PublicKey) *TransferHookExtension {
	obj._programId = programId
	return obj
}

func (obj *TransferHookExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_TransferHookExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *TransferHookExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[TransferHookExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *TransferHookExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *TransferHookExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *TransferHookExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *TransferHookExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("TransferHookExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// ConfidentialTransferFeeExtension Instruction
type ConfidentialTransferFeeExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewConfidentialTransferFeeExtensionInstructionBuilder creates a new `ConfidentialTransferFeeExtension` instruction builder.
func NewConfidentialTransferFeeExtensionInstructionBuilder() *ConfidentialTransferFeeExtension {
	return &ConfidentialTransferFeeExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewConfidentialTransferFeeExtensionInstruction
//
// Parameters:
//
//	data:
func NewConfidentialTransferFeeExtensionInstruction(
	data []byte,
) *ConfidentialTransferFeeExtension {
	return NewConfidentialTransferFeeExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *ConfidentialTransferFeeExtension) SetData(data []byte) *ConfidentialTransferFeeExtension {
	obj.Data = data
	return obj
}

func (obj *ConfidentialTransferFeeExtension) SetProgramId(programId *common.PublicKey) *ConfidentialTransferFeeExtension {
	obj._programId = programId
	return obj
}

func (obj *ConfidentialTransferFeeExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ConfidentialTransferFeeExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ConfidentialTransferFeeExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[ConfidentialTransferFeeExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ConfidentialTransferFeeExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ConfidentialTransferFeeExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *ConfidentialTransferFeeExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *ConfidentialTransferFeeExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ConfidentialTransferFeeExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// WithdrawExcessLamports Instruction
type WithdrawExcessLamports struct {
	// [0] = [WRITE] source `Source Account owned by the token program`
	// [1] = [WRITE] destination `Destination account`
	// [2] = [SIGNER] authority `Authority,3. ..2+M `[signer]` M signer accounts.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewWithdrawExcessLamportsInstructionBuilder creates a new `WithdrawExcessLamports` instruction builder.
func NewWithdrawExcessLamportsInstructionBuilder() *WithdrawExcessLamports {
	return &WithdrawExcessLamports{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewWithdrawExcessLamportsInstruction
//
// Parameters:
//   source: Source Account owned by the token program
//   destination: Destination account
/*
  authority: Authority
  3. ..2+M `[signer]` M signer accounts.
*/
//
func NewWithdrawExcessLamportsInstruction(
	source common.PublicKey,
	destination common.PublicKey,
	authority common.PublicKey,
) *WithdrawExcessLamports {
	return NewWithdrawExcessLamportsInstructionBuilder().
		SetSourceAccount(source).
		SetDestinationAccount(destination).
		SetAuthorityAccount(authority)
}

// SetSourceAccount sets the "source" parameter.
// Source Account owned by the token program
func (obj *WithdrawExcessLamports) SetSourceAccount(source common.PublicKey) *WithdrawExcessLamports {
	obj.AccountMetaSlice[0] = common.Meta(source).WRITE()
	return obj
}

// GetSourceAccount gets the "source" parameter.
// Source Account owned by the token program
func (obj *WithdrawExcessLamports) GetSourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDestinationAccount sets the "destination" parameter.
// Destination account
func (obj *WithdrawExcessLamports) SetDestinationAccount(destination common.PublicKey) *WithdrawExcessLamports {
	obj.AccountMetaSlice[1] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// Destination account
func (obj *WithdrawExcessLamports) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetAuthorityAccount sets the "authority" parameter.
// Authority
// 3. ..2+M `[signer]` M signer accounts.
func (obj *WithdrawExcessLamports) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *WithdrawExcessLamports {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Authority
// 3. ..2+M `[signer]` M signer accounts.
func (obj *WithdrawExcessLamports) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *WithdrawExcessLamports) SetProgramId(programId *common.PublicKey) *WithdrawExcessLamports {
	obj._programId = programId
	return obj
}

func (obj *WithdrawExcessLamports) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_WithdrawExcessLamports}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *WithdrawExcessLamports) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[WithdrawExcessLamports] accounts.source is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[WithdrawExcessLamports] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[WithdrawExcessLamports] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *WithdrawExcessLamports) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *WithdrawExcessLamports) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *WithdrawExcessLamports) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *WithdrawExcessLamports) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("WithdrawExcessLamports")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     source", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("destination", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  authority", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// MetadataPointerExtension Instruction
type MetadataPointerExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMetadataPointerExtensionInstructionBuilder creates a new `MetadataPointerExtension` instruction builder.
func NewMetadataPointerExtensionInstructionBuilder() *MetadataPointerExtension {
	return &MetadataPointerExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewMetadataPointerExtensionInstruction
//
// Parameters:
//
//	data:
func NewMetadataPointerExtensionInstruction(
	data []byte,
) *MetadataPointerExtension {
	return NewMetadataPointerExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *MetadataPointerExtension) SetData(data []byte) *MetadataPointerExtension {
	obj.Data = data
	return obj
}

func (obj *MetadataPointerExtension) SetProgramId(programId *common.PublicKey) *MetadataPointerExtension {
	obj._programId = programId
	return obj
}

func (obj *MetadataPointerExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MetadataPointerExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MetadataPointerExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[MetadataPointerExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MetadataPointerExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MetadataPointerExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *MetadataPointerExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *MetadataPointerExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MetadataPointerExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// GroupPointerExtension Instruction
type GroupPointerExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewGroupPointerExtensionInstructionBuilder creates a new `GroupPointerExtension` instruction builder.
func NewGroupPointerExtensionInstructionBuilder() *GroupPointerExtension {
	return &GroupPointerExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewGroupPointerExtensionInstruction
//
// Parameters:
//
//	data:
func NewGroupPointerExtensionInstruction(
	data []byte,
) *GroupPointerExtension {
	return NewGroupPointerExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *GroupPointerExtension) SetData(data []byte) *GroupPointerExtension {
	obj.Data = data
	return obj
}

func (obj *GroupPointerExtension) SetProgramId(programId *common.PublicKey) *GroupPointerExtension {
	obj._programId = programId
	return obj
}

func (obj *GroupPointerExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_GroupPointerExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *GroupPointerExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[GroupPointerExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *GroupPointerExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *GroupPointerExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *GroupPointerExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *GroupPointerExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("GroupPointerExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}

// GroupMemberPointerExtension Instruction
type GroupMemberPointerExtension struct {
	Data                    []byte
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewGroupMemberPointerExtensionInstructionBuilder creates a new `GroupMemberPointerExtension` instruction builder.
func NewGroupMemberPointerExtensionInstructionBuilder() *GroupMemberPointerExtension {
	return &GroupMemberPointerExtension{
		AccountMetaSlice: make(common.AccountMetaSlice, 0),
	}
}

// NewGroupMemberPointerExtensionInstruction
//
// Parameters:
//
//	data:
func NewGroupMemberPointerExtensionInstruction(
	data []byte,
) *GroupMemberPointerExtension {
	return NewGroupMemberPointerExtensionInstructionBuilder().
		SetData(data)
}

// SetData sets the "data" parameter.
func (obj *GroupMemberPointerExtension) SetData(data []byte) *GroupMemberPointerExtension {
	obj.Data = data
	return obj
}

func (obj *GroupMemberPointerExtension) SetProgramId(programId *common.PublicKey) *GroupMemberPointerExtension {
	obj._programId = programId
	return obj
}

func (obj *GroupMemberPointerExtension) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_GroupMemberPointerExtension}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *GroupMemberPointerExtension) Validate() error {
	if obj.Data == nil {
		return errors.New("[GroupMemberPointerExtension] data param is not set")
	}

	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *GroupMemberPointerExtension) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *GroupMemberPointerExtension) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.WriteBytes(obj.Data, false); err != nil {
		return err
	}
	return nil
}

func (obj *GroupMemberPointerExtension) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if obj.Data, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return err
	}
	return nil
}

func (obj *GroupMemberPointerExtension) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("GroupMemberPointerExtension")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("Data", obj.Data))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=0]").ParentFunc(func(accountsBranch treeout.Branches) {})
				})
		})
}
