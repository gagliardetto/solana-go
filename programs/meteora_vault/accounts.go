// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_vault

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type Vault struct {
	// The flag, if admin set enable = false, then the user can only withdraw and cannot deposit in the vault.
	Enabled uint8

	// Vault nonce, to create vault seeds
	Bumps VaultBumps

	// The total liquidity of the vault, including remaining tokens in token_vault and the liquidity in all strategies.
	TotalAmount uint64

	// Token account, hold liquidity in vault reserve
	TokenVault ag_solanago.PublicKey

	// Hold lp token of vault, each time rebalance crank is called, vault calculate performance fee and mint corresponding lp token amount to fee_vault. fee_vault is owned by treasury address
	FeeVault ag_solanago.PublicKey

	// Token mint that vault supports
	TokenMint ag_solanago.PublicKey

	// Lp mint of vault
	LpMint ag_solanago.PublicKey

	// The list of strategy addresses that vault supports, vault can support up to MAX_STRATEGY strategies at the same time.
	Strategies [30]ag_solanago.PublicKey

	// The base address to create vault seeds
	Base ag_solanago.PublicKey

	// Admin of vault
	Admin ag_solanago.PublicKey

	// Person who can send the crank. Operator can only send liquidity to strategies that admin defined, and claim reward to account of treasury address
	Operator ag_solanago.PublicKey

	// Stores information for locked profit.
	LockedProfitTracker LockedProfitTracker
}

var VaultDiscriminator = [8]byte{211, 8, 232, 43, 2, 152, 117, 119}

func (obj Vault) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(VaultDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Enabled` param:
	err = encoder.Encode(obj.Enabled)
	if err != nil {
		return err
	}
	// Serialize `Bumps` param:
	err = encoder.Encode(obj.Bumps)
	if err != nil {
		return err
	}
	// Serialize `TotalAmount` param:
	err = encoder.Encode(obj.TotalAmount)
	if err != nil {
		return err
	}
	// Serialize `TokenVault` param:
	err = encoder.Encode(obj.TokenVault)
	if err != nil {
		return err
	}
	// Serialize `FeeVault` param:
	err = encoder.Encode(obj.FeeVault)
	if err != nil {
		return err
	}
	// Serialize `TokenMint` param:
	err = encoder.Encode(obj.TokenMint)
	if err != nil {
		return err
	}
	// Serialize `LpMint` param:
	err = encoder.Encode(obj.LpMint)
	if err != nil {
		return err
	}
	// Serialize `Strategies` param:
	err = encoder.Encode(obj.Strategies)
	if err != nil {
		return err
	}
	// Serialize `Base` param:
	err = encoder.Encode(obj.Base)
	if err != nil {
		return err
	}
	// Serialize `Admin` param:
	err = encoder.Encode(obj.Admin)
	if err != nil {
		return err
	}
	// Serialize `Operator` param:
	err = encoder.Encode(obj.Operator)
	if err != nil {
		return err
	}
	// Serialize `LockedProfitTracker` param:
	err = encoder.Encode(obj.LockedProfitTracker)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Vault) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(VaultDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[211 8 232 43 2 152 117 119]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Enabled`:
	err = decoder.Decode(&obj.Enabled)
	if err != nil {
		return err
	}
	// Deserialize `Bumps`:
	err = decoder.Decode(&obj.Bumps)
	if err != nil {
		return err
	}
	// Deserialize `TotalAmount`:
	err = decoder.Decode(&obj.TotalAmount)
	if err != nil {
		return err
	}
	// Deserialize `TokenVault`:
	err = decoder.Decode(&obj.TokenVault)
	if err != nil {
		return err
	}
	// Deserialize `FeeVault`:
	err = decoder.Decode(&obj.FeeVault)
	if err != nil {
		return err
	}
	// Deserialize `TokenMint`:
	err = decoder.Decode(&obj.TokenMint)
	if err != nil {
		return err
	}
	// Deserialize `LpMint`:
	err = decoder.Decode(&obj.LpMint)
	if err != nil {
		return err
	}
	// Deserialize `Strategies`:
	err = decoder.Decode(&obj.Strategies)
	if err != nil {
		return err
	}
	// Deserialize `Base`:
	err = decoder.Decode(&obj.Base)
	if err != nil {
		return err
	}
	// Deserialize `Admin`:
	err = decoder.Decode(&obj.Admin)
	if err != nil {
		return err
	}
	// Deserialize `Operator`:
	err = decoder.Decode(&obj.Operator)
	if err != nil {
		return err
	}
	// Deserialize `LockedProfitTracker`:
	err = decoder.Decode(&obj.LockedProfitTracker)
	if err != nil {
		return err
	}
	return nil
}

type Strategy struct {
	// Lending pool address, that the strategy will deposit/withdraw balance
	Reserve ag_solanago.PublicKey

	// The token account, that holds the collateral token
	CollateralVault ag_solanago.PublicKey

	// Specify type of strategy
	StrategyType StrategyType

	// The liquidity in strategy at the time vault deposit/withdraw from a lending protocol
	CurrentLiquidity uint64

	// Hold some bumps, in case the strategy needs to use other seeds to sign a CPI call.
	Bumps [10]uint8

	// Vault address, that the strategy belongs
	Vault ag_solanago.PublicKey

	// If we remove strategy by remove_strategy2 endpoint, this account will be never added again
	IsDisable uint8
}

var StrategyDiscriminator = [8]byte{174, 110, 39, 119, 82, 106, 169, 102}

func (obj Strategy) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(StrategyDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Reserve` param:
	err = encoder.Encode(obj.Reserve)
	if err != nil {
		return err
	}
	// Serialize `CollateralVault` param:
	err = encoder.Encode(obj.CollateralVault)
	if err != nil {
		return err
	}
	// Serialize `StrategyType` param:
	err = encoder.Encode(obj.StrategyType)
	if err != nil {
		return err
	}
	// Serialize `CurrentLiquidity` param:
	err = encoder.Encode(obj.CurrentLiquidity)
	if err != nil {
		return err
	}
	// Serialize `Bumps` param:
	err = encoder.Encode(obj.Bumps)
	if err != nil {
		return err
	}
	// Serialize `Vault` param:
	err = encoder.Encode(obj.Vault)
	if err != nil {
		return err
	}
	// Serialize `IsDisable` param:
	err = encoder.Encode(obj.IsDisable)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Strategy) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(StrategyDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[174 110 39 119 82 106 169 102]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Reserve`:
	err = decoder.Decode(&obj.Reserve)
	if err != nil {
		return err
	}
	// Deserialize `CollateralVault`:
	err = decoder.Decode(&obj.CollateralVault)
	if err != nil {
		return err
	}
	// Deserialize `StrategyType`:
	err = decoder.Decode(&obj.StrategyType)
	if err != nil {
		return err
	}
	// Deserialize `CurrentLiquidity`:
	err = decoder.Decode(&obj.CurrentLiquidity)
	if err != nil {
		return err
	}
	// Deserialize `Bumps`:
	err = decoder.Decode(&obj.Bumps)
	if err != nil {
		return err
	}
	// Deserialize `Vault`:
	err = decoder.Decode(&obj.Vault)
	if err != nil {
		return err
	}
	// Deserialize `IsDisable`:
	err = decoder.Decode(&obj.IsDisable)
	if err != nil {
		return err
	}
	return nil
}
