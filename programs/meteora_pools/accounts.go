// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_pools

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type Config struct {
	PoolFees           PoolFees
	ActivationDuration uint64
	VaultConfigKey     ag_solanago.PublicKey

	// Only pool_creator_authority can use the current config to initialize new pool. When it's Pubkey::default, it's a public config.
	PoolCreatorAuthority ag_solanago.PublicKey

	// Activation type
	ActivationType      uint8
	PartnerFeeNumerator uint64
	Padding             [219]uint8
}

var ConfigDiscriminator = [8]byte{155, 12, 170, 224, 30, 250, 204, 130}

func (obj Config) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ConfigDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `PoolFees` param:
	err = encoder.Encode(obj.PoolFees)
	if err != nil {
		return err
	}
	// Serialize `ActivationDuration` param:
	err = encoder.Encode(obj.ActivationDuration)
	if err != nil {
		return err
	}
	// Serialize `VaultConfigKey` param:
	err = encoder.Encode(obj.VaultConfigKey)
	if err != nil {
		return err
	}
	// Serialize `PoolCreatorAuthority` param:
	err = encoder.Encode(obj.PoolCreatorAuthority)
	if err != nil {
		return err
	}
	// Serialize `ActivationType` param:
	err = encoder.Encode(obj.ActivationType)
	if err != nil {
		return err
	}
	// Serialize `PartnerFeeNumerator` param:
	err = encoder.Encode(obj.PartnerFeeNumerator)
	if err != nil {
		return err
	}
	// Serialize `Padding` param:
	err = encoder.Encode(obj.Padding)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Config) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ConfigDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[155 12 170 224 30 250 204 130]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `PoolFees`:
	err = decoder.Decode(&obj.PoolFees)
	if err != nil {
		return err
	}
	// Deserialize `ActivationDuration`:
	err = decoder.Decode(&obj.ActivationDuration)
	if err != nil {
		return err
	}
	// Deserialize `VaultConfigKey`:
	err = decoder.Decode(&obj.VaultConfigKey)
	if err != nil {
		return err
	}
	// Deserialize `PoolCreatorAuthority`:
	err = decoder.Decode(&obj.PoolCreatorAuthority)
	if err != nil {
		return err
	}
	// Deserialize `ActivationType`:
	err = decoder.Decode(&obj.ActivationType)
	if err != nil {
		return err
	}
	// Deserialize `PartnerFeeNumerator`:
	err = decoder.Decode(&obj.PartnerFeeNumerator)
	if err != nil {
		return err
	}
	// Deserialize `Padding`:
	err = decoder.Decode(&obj.Padding)
	if err != nil {
		return err
	}
	return nil
}

type LockEscrow struct {
	// Pool address
	Pool ag_solanago.PublicKey

	// Owner address
	Owner ag_solanago.PublicKey

	// Vault address, store the lock user lock
	EscrowVault ag_solanago.PublicKey

	// bump, used to sign
	Bump uint8

	// Total locked amount
	TotalLockedAmount uint64

	// Lp per token, virtual price of lp token
	LpPerToken ag_binary.Uint128

	// Unclaimed fee pending
	UnclaimedFeePending uint64

	// Total a fee claimed so far
	AFee uint64

	// Total b fee claimed so far
	BFee uint64
}

var LockEscrowDiscriminator = [8]byte{190, 106, 121, 6, 200, 182, 21, 75}

func (obj LockEscrow) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(LockEscrowDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Pool` param:
	err = encoder.Encode(obj.Pool)
	if err != nil {
		return err
	}
	// Serialize `Owner` param:
	err = encoder.Encode(obj.Owner)
	if err != nil {
		return err
	}
	// Serialize `EscrowVault` param:
	err = encoder.Encode(obj.EscrowVault)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `TotalLockedAmount` param:
	err = encoder.Encode(obj.TotalLockedAmount)
	if err != nil {
		return err
	}
	// Serialize `LpPerToken` param:
	err = encoder.Encode(obj.LpPerToken)
	if err != nil {
		return err
	}
	// Serialize `UnclaimedFeePending` param:
	err = encoder.Encode(obj.UnclaimedFeePending)
	if err != nil {
		return err
	}
	// Serialize `AFee` param:
	err = encoder.Encode(obj.AFee)
	if err != nil {
		return err
	}
	// Serialize `BFee` param:
	err = encoder.Encode(obj.BFee)
	if err != nil {
		return err
	}
	return nil
}

func (obj *LockEscrow) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(LockEscrowDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[190 106 121 6 200 182 21 75]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Pool`:
	err = decoder.Decode(&obj.Pool)
	if err != nil {
		return err
	}
	// Deserialize `Owner`:
	err = decoder.Decode(&obj.Owner)
	if err != nil {
		return err
	}
	// Deserialize `EscrowVault`:
	err = decoder.Decode(&obj.EscrowVault)
	if err != nil {
		return err
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `TotalLockedAmount`:
	err = decoder.Decode(&obj.TotalLockedAmount)
	if err != nil {
		return err
	}
	// Deserialize `LpPerToken`:
	err = decoder.Decode(&obj.LpPerToken)
	if err != nil {
		return err
	}
	// Deserialize `UnclaimedFeePending`:
	err = decoder.Decode(&obj.UnclaimedFeePending)
	if err != nil {
		return err
	}
	// Deserialize `AFee`:
	err = decoder.Decode(&obj.AFee)
	if err != nil {
		return err
	}
	// Deserialize `BFee`:
	err = decoder.Decode(&obj.BFee)
	if err != nil {
		return err
	}
	return nil
}

type Pool struct {
	// LP token mint of the pool
	LpMint ag_solanago.PublicKey

	// Token A mint of the pool. Eg: USDT
	TokenAMint ag_solanago.PublicKey

	// Token B mint of the pool. Eg: USDC
	TokenBMint ag_solanago.PublicKey

	// Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account.
	AVault ag_solanago.PublicKey

	// Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account.
	BVault ag_solanago.PublicKey

	// LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
	AVaultLp ag_solanago.PublicKey

	// LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
	BVaultLp ag_solanago.PublicKey

	// "A" vault lp bump. Used to create signer seeds.
	AVaultLpBump uint8

	// Flag to determine whether the pool is enabled, or disabled.
	Enabled bool

	// Protocol fee token account for token A. Used to receive trading fee.
	ProtocolTokenAFee ag_solanago.PublicKey

	// Protocol fee token account for token B. Used to receive trading fee.
	ProtocolTokenBFee ag_solanago.PublicKey

	// Fee last updated timestamp
	FeeLastUpdatedAt uint64
	Padding0         [24]uint8

	// Store the fee charges setting.
	Fees PoolFees

	// Pool type
	PoolType PoolType

	// Stake pubkey of SPL stake pool
	Stake ag_solanago.PublicKey

	// Total locked lp token
	TotalLockedLp uint64

	// bootstrapping config
	Bootstrapping Bootstrapping
	PartnerInfo   PartnerInfo

	// Padding for future pool field
	Padding Padding

	// The type of the swap curve supported by the pool.
	CurveType CurveType
}

var PoolDiscriminator = [8]byte{241, 154, 109, 4, 17, 177, 109, 188}

func (obj Pool) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(PoolDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `LpMint` param:
	err = encoder.Encode(obj.LpMint)
	if err != nil {
		return err
	}
	// Serialize `TokenAMint` param:
	err = encoder.Encode(obj.TokenAMint)
	if err != nil {
		return err
	}
	// Serialize `TokenBMint` param:
	err = encoder.Encode(obj.TokenBMint)
	if err != nil {
		return err
	}
	// Serialize `AVault` param:
	err = encoder.Encode(obj.AVault)
	if err != nil {
		return err
	}
	// Serialize `BVault` param:
	err = encoder.Encode(obj.BVault)
	if err != nil {
		return err
	}
	// Serialize `AVaultLp` param:
	err = encoder.Encode(obj.AVaultLp)
	if err != nil {
		return err
	}
	// Serialize `BVaultLp` param:
	err = encoder.Encode(obj.BVaultLp)
	if err != nil {
		return err
	}
	// Serialize `AVaultLpBump` param:
	err = encoder.Encode(obj.AVaultLpBump)
	if err != nil {
		return err
	}
	// Serialize `Enabled` param:
	err = encoder.Encode(obj.Enabled)
	if err != nil {
		return err
	}
	// Serialize `ProtocolTokenAFee` param:
	err = encoder.Encode(obj.ProtocolTokenAFee)
	if err != nil {
		return err
	}
	// Serialize `ProtocolTokenBFee` param:
	err = encoder.Encode(obj.ProtocolTokenBFee)
	if err != nil {
		return err
	}
	// Serialize `FeeLastUpdatedAt` param:
	err = encoder.Encode(obj.FeeLastUpdatedAt)
	if err != nil {
		return err
	}
	// Serialize `Padding0` param:
	err = encoder.Encode(obj.Padding0)
	if err != nil {
		return err
	}
	// Serialize `Fees` param:
	err = encoder.Encode(obj.Fees)
	if err != nil {
		return err
	}
	// Serialize `PoolType` param:
	err = encoder.Encode(obj.PoolType)
	if err != nil {
		return err
	}
	// Serialize `Stake` param:
	err = encoder.Encode(obj.Stake)
	if err != nil {
		return err
	}
	// Serialize `TotalLockedLp` param:
	err = encoder.Encode(obj.TotalLockedLp)
	if err != nil {
		return err
	}
	// Serialize `Bootstrapping` param:
	err = encoder.Encode(obj.Bootstrapping)
	if err != nil {
		return err
	}
	// Serialize `PartnerInfo` param:
	err = encoder.Encode(obj.PartnerInfo)
	if err != nil {
		return err
	}
	// Serialize `Padding` param:
	err = encoder.Encode(obj.Padding)
	if err != nil {
		return err
	}
	// Serialize `CurveType` param:
	{
		tmp := curveTypeContainer{}
		switch realvalue := obj.CurveType.(type) {
		case *CurveTypeConstantProduct:
			tmp.Enum = 0
			tmp.ConstantProduct = *realvalue
		case *CurveTypeStable:
			tmp.Enum = 1
			tmp.Stable = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	return nil
}

func (obj *Pool) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(PoolDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[241 154 109 4 17 177 109 188]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `LpMint`:
	err = decoder.Decode(&obj.LpMint)
	if err != nil {
		return err
	}
	// Deserialize `TokenAMint`:
	err = decoder.Decode(&obj.TokenAMint)
	if err != nil {
		return err
	}
	// Deserialize `TokenBMint`:
	err = decoder.Decode(&obj.TokenBMint)
	if err != nil {
		return err
	}
	// Deserialize `AVault`:
	err = decoder.Decode(&obj.AVault)
	if err != nil {
		return err
	}
	// Deserialize `BVault`:
	err = decoder.Decode(&obj.BVault)
	if err != nil {
		return err
	}
	// Deserialize `AVaultLp`:
	err = decoder.Decode(&obj.AVaultLp)
	if err != nil {
		return err
	}
	// Deserialize `BVaultLp`:
	err = decoder.Decode(&obj.BVaultLp)
	if err != nil {
		return err
	}
	// Deserialize `AVaultLpBump`:
	err = decoder.Decode(&obj.AVaultLpBump)
	if err != nil {
		return err
	}
	// Deserialize `Enabled`:
	err = decoder.Decode(&obj.Enabled)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolTokenAFee`:
	err = decoder.Decode(&obj.ProtocolTokenAFee)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolTokenBFee`:
	err = decoder.Decode(&obj.ProtocolTokenBFee)
	if err != nil {
		return err
	}
	// Deserialize `FeeLastUpdatedAt`:
	err = decoder.Decode(&obj.FeeLastUpdatedAt)
	if err != nil {
		return err
	}
	// Deserialize `Padding0`:
	err = decoder.Decode(&obj.Padding0)
	if err != nil {
		return err
	}
	// Deserialize `Fees`:
	err = decoder.Decode(&obj.Fees)
	if err != nil {
		return err
	}
	// Deserialize `PoolType`:
	err = decoder.Decode(&obj.PoolType)
	if err != nil {
		return err
	}
	// Deserialize `Stake`:
	err = decoder.Decode(&obj.Stake)
	if err != nil {
		return err
	}
	// Deserialize `TotalLockedLp`:
	err = decoder.Decode(&obj.TotalLockedLp)
	if err != nil {
		return err
	}
	// Deserialize `Bootstrapping`:
	err = decoder.Decode(&obj.Bootstrapping)
	if err != nil {
		return err
	}
	// Deserialize `PartnerInfo`:
	err = decoder.Decode(&obj.PartnerInfo)
	if err != nil {
		return err
	}
	// Deserialize `Padding`:
	err = decoder.Decode(&obj.Padding)
	if err != nil {
		return err
	}
	// Deserialize `CurveType`:
	{
		tmp := new(curveTypeContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.CurveType = (*CurveTypeConstantProduct)(&tmp.Enum)
		case 1:
			obj.CurveType = &tmp.Stable
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	return nil
}
